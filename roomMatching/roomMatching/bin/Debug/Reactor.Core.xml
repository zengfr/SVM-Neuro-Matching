<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Reactor.Core</name>
    </assembly>
    <members>
        <member name="T:Reactor.Core.BackpressureHandling">
            <summary>
            Handling of backpressure for FluxEmitter and IObservable conversions.
            </summary>
        </member>
        <member name="F:Reactor.Core.BackpressureHandling.None">
            <summary>
            Completely ignore backpressure.
            </summary>
        </member>
        <member name="F:Reactor.Core.BackpressureHandling.Error">
            <summary>
            Signal an error if the downstream can't keep up.
            </summary>
        </member>
        <member name="F:Reactor.Core.BackpressureHandling.Drop">
            <summary>
            Drop the overflown item.
            </summary>
        </member>
        <member name="F:Reactor.Core.BackpressureHandling.Latest">
            <summary>
            Keep only the latest item.
            </summary>
        </member>
        <member name="F:Reactor.Core.BackpressureHandling.Buffer">
            <summary>
            Buffer all items.
            </summary>
        </member>
        <member name="T:Reactor.Core.ConcatErrorMode">
            <summary>
            Indicates when an error should be delivered in a Concat/ConcatMap operator.
            </summary>
        </member>
        <member name="F:Reactor.Core.ConcatErrorMode.Immediate">
            <summary>
            If any of the participating IPublisher signals an OnError, that error is delivered immediately.
            </summary>
        </member>
        <member name="F:Reactor.Core.ConcatErrorMode.Boundary">
            <summary>
            If any of the participating IPublisher signals an OnError, that error is delivered when the current
            inner IPublisher terminates. If multiple OnError signals happened,
            the downstream will receive all of them in an AggregateException.
            </summary>
        </member>
        <member name="F:Reactor.Core.ConcatErrorMode.End">
            <summary>
            If any of the participating IPublisher signals an OnError, that error is delivered only when
            the outer and all the inner IPublishers have terminated. If multiple OnError signals happened,
            the downstream will receive all of them in an AggregateException.
            </summary>
        </member>
        <member name="T:Reactor.Core.ConnectableFlux">
            <summary>
            Extension methods to work with <seealso cref="T:Reactor.Core.IConnectableFlux`1"/> instances.
            </summary>
        </member>
        <member name="M:Reactor.Core.ConnectableFlux.AutoConnect``1(Reactor.Core.IConnectableFlux{``0},System.Int32,System.Action{System.IDisposable})">
            <summary>
            Automatically connect to the source if the number of arriving
            ISubscribers reaches the specified number.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IConnectableFlux to connect to.</param>
            <param name="n">The minimum number of Subscribers to connect to the source.
            Zero connects immediately.</param>
            <param name="onConnect">The callback to receive a disposable that let's disconnect
            the established connection.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="T:Reactor.Core.DirectProcessor`1">
            <summary>
            An IProcessor with same input and output type that dispatches signals to ISubscribers.
            Consumers unable to keep up will receive an InvalidOperationException.
            </summary>
            <typeparam name="T">The input and output value type</typeparam>
        </member>
        <member name="P:Reactor.Core.DirectProcessor`1.HasSubscribers">
            <inheritDoc/>
        </member>
        <member name="P:Reactor.Core.DirectProcessor`1.IsComplete">
            <inheritDoc/>
        </member>
        <member name="P:Reactor.Core.DirectProcessor`1.HasError">
            <inheritDoc/>
        </member>
        <member name="P:Reactor.Core.DirectProcessor`1.Error">
            <inheritDoc/>
        </member>
        <member name="M:Reactor.Core.DirectProcessor`1.#ctor">
            <summary>
            Constructs a fresh DirectProcessor.
            </summary>
        </member>
        <member name="M:Reactor.Core.DirectProcessor`1.OnSubscribe(Reactive.Streams.ISubscription)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.DirectProcessor`1.OnNext(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.DirectProcessor`1.OnError(System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.DirectProcessor`1.OnComplete">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.DirectProcessor`1.Subscribe(Reactive.Streams.ISubscriber{`0})">
            <inheritdoc/>
        </member>
        <member name="T:Reactor.Core.IConnectableFlux`1">
            <summary>
            Represents a connectable IFlux that starts streaming
            only when the <see cref="M:Reactor.Core.IConnectableFlux`1.Connect(System.Action{System.IDisposable})"/> is called.
            </summary>
            <typeparam name="T">The value type</typeparam>
        </member>
        <member name="M:Reactor.Core.IConnectableFlux`1.Connect(System.Action{System.IDisposable})">
            <summary>
            Connect to the upstream IFlux.
            </summary>
            <param name="onConnect">If given, it is called with a disposable instance that allows in-sequence connectioncancellation.</param>
            <returns>The IDisposable to cancel the connection</returns>
        </member>
        <member name="T:Reactor.Core.flow.ICallable`1">
            <summary>
            Indicates an IPublisher holds a single value that can be computed or
            retrieved at subscription time.
            </summary>
            <typeparam name="T">The returned value type.</typeparam>
        </member>
        <member name="P:Reactor.Core.flow.ICallable`1.Value">
            <summary>
            Returns the value.
            </summary>
        </member>
        <member name="T:Reactor.Core.flow.IScalarCallable`1">
            <summary>
            Indicates an IPublisher holds a single, constant value that can
            be retrieved at assembly time.
            </summary>
            <typeparam name="T">The returned value type.</typeparam>
        </member>
        <member name="T:Reactor.Core.flow.IConditionalSubscriber`1">
            <summary>
            Represents a conditional ISubscriber that has a TryOnNext() method
            to avoid requesting replenishments one-by-one
            </summary>
            <typeparam name="T">The value type</typeparam>
        </member>
        <member name="M:Reactor.Core.flow.IConditionalSubscriber`1.TryOnNext(`0)">
            <summary>
            Try signalling a value and return true if successful,
            false to indicate a new value can be immediately sent out.
            </summary>
            <param name="t">The value signalled</param>
            <returns>True if the value has been consumed, false if a new value can be
            sent immediately</returns>
        </member>
        <member name="T:Reactor.Core.flow.FuseableHelper">
            <summary>
            Constants for <see cref="M:Reactor.Core.flow.IQueueSubscription`1.RequestFusion(System.Int32)"/> parameter
            and return types.
            </summary>
        </member>
        <member name="F:Reactor.Core.flow.FuseableHelper.NONE">
            <summary>
            Returned by the <see cref="M:Reactor.Core.flow.IQueueSubscription`1.RequestFusion(System.Int32)"/> method to indicate no fusion will take place.
            </summary>
        </member>
        <member name="F:Reactor.Core.flow.FuseableHelper.SYNC">
            <summary>
            Requested and returned by the <see cref="M:Reactor.Core.flow.IQueueSubscription`1.RequestFusion(System.Int32)"/> to indicate synchronous fusion.
            </summary>
        </member>
        <member name="F:Reactor.Core.flow.FuseableHelper.ASYNC">
            <summary>
            Requested and returned by the <see cref="M:Reactor.Core.flow.IQueueSubscription`1.RequestFusion(System.Int32)"/> method to indicate asynchronous fusion.
            </summary>
        </member>
        <member name="F:Reactor.Core.flow.FuseableHelper.ANY">
            <summary>
            Combination of <see cref="F:Reactor.Core.flow.FuseableHelper.SYNC"/> and <see cref="F:Reactor.Core.flow.FuseableHelper.ASYNC"/> constants.
            </summary>
        </member>
        <member name="F:Reactor.Core.flow.FuseableHelper.BOUNDARY">
            <summary>
            Requested and returned by the <see cref="M:Reactor.Core.flow.IQueueSubscription`1.RequestFusion(System.Int32)"/> method 
            to indicate that the requestor is a thread-boundary.
            </summary>
        </member>
        <member name="M:Reactor.Core.flow.FuseableHelper.DontCallOffer">
            <summary>
            Handle the case when the <see cref="M:Reactor.Core.flow.IQueue`1.Offer(`0)"/> is called on a
            <see cref="T:Reactor.Core.flow.IQueueSubscription`1"/>.
            </summary>
            <returns>Never completes normally.</returns>
        </member>
        <member name="M:Reactor.Core.flow.FuseableHelper.ToString(System.Int32)">
            <summary>
            Convert the mode flags into a string.
            </summary>
            <param name="mode">The mode flags.</param>
            <returns>The string representing the mode flags.</returns>
        </member>
        <member name="T:Reactor.Core.flow.IQueue`1">
            <summary>
            The standard queue interface.
            </summary>
            <typeparam name="T">The value type</typeparam>
        </member>
        <member name="M:Reactor.Core.flow.IQueue`1.Offer(`0)">
            <summary>
            Offers the given value and returns true if the queue is not full.
            </summary>
            <param name="value">The value to enqueue.</param>
            <returns>True if successful, false if the queue is full.</returns>
        </member>
        <member name="M:Reactor.Core.flow.IQueue`1.Poll(`0@)">
            <summary>
            Tries polling a value into the output value and returns true
            if successful
            </summary>
            <param name="value">The output to dequeue the value into</param>
            <returns>True if a value was polled, false if the queue is empty</returns>
        </member>
        <member name="M:Reactor.Core.flow.IQueue`1.IsEmpty">
            <summary>
            Returns true if the queue is empty.
            </summary>
            <returns>True if the queue is empty.</returns>
        </member>
        <member name="M:Reactor.Core.flow.IQueue`1.Clear">
            <summary>
            Clears the queue.
            </summary>
        </member>
        <member name="T:Reactor.Core.flow.IQueueSubscription`1">
            <summary>
            A combination of an IQueue and an ISubscription to allow queue fusion.
            </summary>
            <typeparam name="T">The value type in the queue.</typeparam>
        </member>
        <member name="M:Reactor.Core.flow.IQueueSubscription`1.RequestFusion(System.Int32)">
            <summary>
            Indicate the intent to fuse two subsequent operators.
            </summary>
            <param name="mode">The wanted fusion mode. See the <see cref="T:Reactor.Core.flow.FuseableHelper"/> constants.</param>
            <returns>The established fusion mode. See the <see cref="T:Reactor.Core.flow.FuseableHelper"/> constants.</returns>
        </member>
        <member name="T:Reactor.Core.IMonoEmitter`1">
            <summary>
            API surface to signal completion, 1 element followed by a completion or 1 error only,
            hiding an actual ISubscriber.
            </summary>
        </member>
        <member name="M:Reactor.Core.IMonoEmitter`1.Complete(`0)">
            <summary>
            Signal the single value and complete. Disposes any associated resource.
            </summary>
            <param name="t">The value.</param>
        </member>
        <member name="M:Reactor.Core.IMonoEmitter`1.Error(System.Exception)">
            <summary>
            Signal an error. Disposes any associated resource.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Reactor.Core.IMonoEmitter`1.Complete">
            <summary>
            Signal a completion. Disposes any associated resource.
            </summary>
        </member>
        <member name="M:Reactor.Core.IMonoEmitter`1.Stop">
            <summary>
            Indicate no more signals will follow. Further calls
            to the other methods are ignored.
            </summary>
        </member>
        <member name="M:Reactor.Core.IMonoEmitter`1.SetDisposable(System.IDisposable)">
            <summary>
            Associate a resource with the emitter that should
            be disposed on completion or cancellation
            </summary>
            <param name="d">The resource to associate.</param>
        </member>
        <member name="T:Reactor.Core.IFluxEmitter`1">
            <summary>
            API surface to signal 0 to N elements followed by an optional error or completion,
            hiding an actual ISubscriber.
            </summary>
        </member>
        <member name="M:Reactor.Core.IFluxEmitter`1.Next(`0)">
            <summary>
            Signal the next value.
            </summary>
            <param name="t">The value.</param>
        </member>
        <member name="M:Reactor.Core.IFluxEmitter`1.Error(System.Exception)">
            <summary>
            Signal an error. Disposes any associated resource.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Reactor.Core.IFluxEmitter`1.Complete">
            <summary>
            Signal a completion. Disposes any associated resource.
            </summary>
        </member>
        <member name="M:Reactor.Core.IFluxEmitter`1.SetDisposable(System.IDisposable)">
            <summary>
            Associate a resource with the emitter that should
            be disposed on completion or cancellation
            </summary>
            <param name="d">The resource to associate.</param>
        </member>
        <member name="P:Reactor.Core.IFluxEmitter`1.Requested">
            <summary>
            The current requested amount.
            </summary>
        </member>
        <member name="T:Reactor.Core.IFluxProcessor`1">
            <summary>
            An IFlux-typed <see cref="T:Reactive.Streams.IProcessor`1"/>.
            </summary>
            <typeparam name="T">The input and output value type.</typeparam>
        </member>
        <member name="T:Reactor.Core.IFluxProcessor`2">
            <summary>
            An IFlux-typed <see cref="T:Reactive.Streams.IProcessor`2"/>.
            </summary>
            <typeparam name="T">The input value type.</typeparam>
            <typeparam name="R">The output value type</typeparam>
        </member>
        <member name="P:Reactor.Core.IFluxProcessor`2.HasSubscribers">
            <summary>
            Returns true if this IProcessor has subscribers.
            </summary>
        </member>
        <member name="P:Reactor.Core.IFluxProcessor`2.IsComplete">
            <summary>
            Returns true if this IProcessor has completed normally.
            </summary>
        </member>
        <member name="P:Reactor.Core.IFluxProcessor`2.HasError">
            <summary>
            Returns true if this IProcessor has failed.
            </summary>
        </member>
        <member name="P:Reactor.Core.IFluxProcessor`2.Error">
            <summary>
            Returns the failure Exception if <see cref="P:Reactor.Core.IFluxProcessor`2.HasError"/>
            returns true, null otherwise.
            </summary>
        </member>
        <member name="T:Reactor.Core.IFlux`1">
             <summary>
             A Reactive Streams <see cref="T:Reactive.Streams.IPublisher`1"/> with rx operators that emits 0 to N elements, and then completes
             (successfully or with an error).
             </summary>
             <remarks>
             <p>
             <img width = "640" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/flux.png" alt="" />
             </p>
            
             <p>It is intended to be used in implementations and return types.Input parameters should keep using raw
             <see cref="T:Reactive.Streams.IPublisher`1">Publisher</see> as much as possible.</p>
            
             <p>If it is known that the underlying <see cref="T:Reactive.Streams.IPublisher`1">Publisher</see>
             will emit 0 or 1 element, <see cref="T:Reactor.Core.Mono">Mono</see> should be used
             instead.</p>
             </remarks>
        </member>
        <member name="T:Reactor.Core.IGroupedFlux`2">
            <summary>
            Represents an IFlux with a key.
            </summary>
            <typeparam name="K">The key type</typeparam>
            <typeparam name="V">The value type</typeparam>
        </member>
        <member name="P:Reactor.Core.IGroupedFlux`2.Key">
            <summary>
            The key associated with this group.
            </summary>
        </member>
        <member name="T:Reactor.Core.IMono`1">
            <summary>
            A Reactive Streams <see cref="T:Reactive.Streams.IPublisher`1">Publisher</see>
            with basic rx operators that completes successfully by emitting an element, or
            with an error.
            </summary>
        </member>
        <member name="T:Reactor.Core.IParallelFlux`1">
            <summary>
            Base interface for parallel stream processing.
            </summary>
            <typeparam name="T">The value type.</typeparam>
        </member>
        <member name="P:Reactor.Core.IParallelFlux`1.IsOrdered">
            <summary>
            True if the underlying implementation is ordered.
            </summary>
        </member>
        <member name="P:Reactor.Core.IParallelFlux`1.Parallelism">
            <summary>
            The parallelism level of this IParallelFlux.
            </summary>
        </member>
        <member name="M:Reactor.Core.IParallelFlux`1.Subscribe(Reactive.Streams.ISubscriber{`0}[])">
            <summary>
            Subscribes an array of ISubscribers, one for each rail.
            </summary>
            <param name="subscribers">The array of subscribers, its length must be equal
            to the <see cref="P:Reactor.Core.IParallelFlux`1.Parallelism"/> value.</param>
        </member>
        <member name="T:Reactor.Core.ParallelUnorderedFlux`1">
            <summary>
            Base class for unordered parallel stream processing.
            </summary>
            <typeparam name="T">The value type.</typeparam>
        </member>
        <member name="P:Reactor.Core.ParallelUnorderedFlux`1.IsOrdered">
            <inheritdoc/>
        </member>
        <member name="P:Reactor.Core.ParallelUnorderedFlux`1.Parallelism">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.ParallelUnorderedFlux`1.Subscribe(Reactive.Streams.ISubscriber{`0}[])">
            <inheritdoc/>
        </member>
        <member name="T:Reactor.Core.ParallelOrderedFlux`1">
            <summary>
            Base class for ordered parallel stream processing.
            </summary>
            <typeparam name="T">The value type.</typeparam>
        </member>
        <member name="P:Reactor.Core.ParallelOrderedFlux`1.IsOrdered">
            <inheritdoc/>
        </member>
        <member name="P:Reactor.Core.ParallelOrderedFlux`1.Parallelism">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.ParallelOrderedFlux`1.Subscribe(Reactive.Streams.ISubscriber{`0}[])">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.ParallelOrderedFlux`1.SubscribeMany(Reactive.Streams.ISubscriber{Reactor.Core.IOrderedItem{`0}}[])">
            <summary>
            Subscribe an array of ISubscribers to this ordered parallel stream
            that can consume IOrderedItems.
            </summary>
            <param name="subscribers">The array of IOrderedItem-receiving ISubscribers.</param>
        </member>
        <member name="M:Reactor.Core.ParallelFluxHelper.Validate``2(Reactor.Core.IParallelFlux{``0},Reactive.Streams.ISubscriber{``1}[])">
            <summary>
            Validate that the parallelism of the IParallelFlux equals to the number of elements in
            the ISubscriber array. If not, each ISubscriber is notified with an ArgumentException.
            </summary>
            <typeparam name="T">The element type of the parallel flux</typeparam>
            <typeparam name="U">The element type of the ISubscriber array (could be T or IOrderedItem{T})</typeparam>
            <param name="pf">The parent IParallelFlux instance</param>
            <param name="subscribers">The ISubscriber array</param>
            <returns>True if the subscribers were valid</returns>
        </member>
        <member name="T:Reactor.Core.ISignal`1">
            <summary>
            Represents one of the reactive-streams signals.
            </summary>
            <typeparam name="T">The value type held</typeparam>
        </member>
        <member name="P:Reactor.Core.ISignal`1.IsNext">
            <summary>
            Is this signal an OnNext? Use <see cref="P:Reactor.Core.ISignal`1.Next"/> property get the actual value.
            </summary>
        </member>
        <member name="P:Reactor.Core.ISignal`1.IsError">
            <summary>
            Is this signal an OnError? Use <see cref="P:Reactor.Core.ISignal`1.Error"/> property get the actual error.
            </summary>
        </member>
        <member name="P:Reactor.Core.ISignal`1.IsComplete">
            <summary>
            Is this signal an OnComplete?
            </summary>
        </member>
        <member name="P:Reactor.Core.ISignal`1.Next">
            <summary>
            Returns the OnNext value if <see cref="P:Reactor.Core.ISignal`1.IsNext"/> returns true or the type-default value otherwise.
            </summary>
        </member>
        <member name="P:Reactor.Core.ISignal`1.Error">
            <summary>
            Returns the OnError value if <see cref="P:Reactor.Core.ISignal`1.IsError"/> returns true, null otherwise.
            </summary>
        </member>
        <member name="T:Reactor.Core.SignalHelper">
            <summary>
            Utility methods to create and handle ISignal objects.
            </summary>
        </member>
        <member name="M:Reactor.Core.SignalHelper.Next``1(``0)">
            <summary>
            Create an OnNext signal.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Reactor.Core.SignalHelper.Error``1(System.Exception)">
            <summary>
            Create an OnError signal.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:Reactor.Core.SignalHelper.Complete``1">
            <summary>
            Return the singleton OnComplete signal.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Reactor.Core.SignalHelper.Dispatch``1(Reactive.Streams.ISubscriber{``0},Reactor.Core.ISignal{``0})">
            <summary>
            Based on the signal type, call the appropriate ISubscriber method.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="s"></param>
            <param name="signal"></param>
        </member>
        <member name="T:Reactor.Core.Mono">
            <summary>
            Extension methods for IMono sources.
            </summary>
        </member>
        <member name="M:Reactor.Core.Mono.Just``1(``0)">
            <summary>
            Create a new IPublisher that will only emit the passed data then onComplete.
            </summary>
            <typeparam name="T">The value type</typeparam>
            <param name="value">The unique data to emit</param>
            <returns>The new IPublisher instance</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Empty``1">
            <summary>
            Returns an empty instance which completes the ISubscribers immediately.
            </summary>
            <typeparam name="T">The value type</typeparam>
            <returns>The shared Empty instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Never``1">
            <summary>
            Returns an never instance which sets an empty ISubscription and
            does nothing further.
            </summary>
            <typeparam name="T">The value type</typeparam>
            <returns>The shared Never instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Create``1(System.Action{Reactor.Core.IMonoEmitter{``0}})">
            <summary>
            Creates a deferred emitter that can be used with callback-based
            APIs to signal at most one value, a complete or an error signal.
            </summary>
            <typeparam name="T">The type of the value emitted</typeparam>
            <param name="callback">the consumer who will receive a per-subscriber MonoEmitter.</param>
            <returns>A new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Defer``1(System.Func{Reactor.Core.IMono{``0}})">
            <summary>
            Create an IMono provider that will supply a 
            target IMono to subscribe to for each ISubscriber downstream.
            </summary>
            <typeparam name="T">the element type of the returned Mono instance</typeparam>
            <param name="supplier">An IMono factory</param>
            <returns>A new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Delay(System.TimeSpan)">
            <summary>
            Create a Mono which delays an onNext signal by the delay amount and complete
            on the default timed scheduler. If the demand cannot be produced in time, 
            an onError will be signalled instead.
            </summary>
            <param name="delay">The delay amount</param>
            <returns>A new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Delay(System.TimeSpan,Reactor.Core.TimedScheduler)">
            <summary>
            Create a Mono which delays an onNext signal of {@code duration} milliseconds 
            and complete. f the demand cannot be produced in time, an onError will 
            be signalled instead.
            </summary>
            <param name="delay">The delay amount</param>
            <param name="scheduler">The timed scheduler to use for the wait.</param>
            <returns>A new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Empty``1(Reactive.Streams.IPublisher{``0})">
            <summary>
            Create a new {@link Mono} that ignores onNext (dropping them) and only 
            react on Completion signal.
            </summary>
            <typeparam name="T">The element type of the source</typeparam>
            <param name="source">The source to ignore elements of.</param>
            <returns>A new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Error``1(System.Exception,System.Boolean)">
            <summary>
            Creates an IMono instance which signals the given exception
            immediately (or when requested).
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="ex">The exception to signal</param>
            <param name="whenRequested">Signal the exception when requested?</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.First``1(Reactor.Core.IMono{``0}[])">
            <summary>
            Pick the first result coming from any of the given monos and populate 
            a new IMono.
            </summary>
            <typeparam name="T">The common element type of the monos.</typeparam>
            <param name="sources">The deferred monos to use</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.First``1(System.Collections.Generic.IEnumerable{Reactor.Core.IMono{``0}})">
            <summary>
            Pick the first result coming from any of the given monos and populate 
            a new IMono.
            </summary>
            <typeparam name="T">The common element type of the monos.</typeparam>
            <param name="sources">The deferred monos to use</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.From``1(Reactive.Streams.IPublisher{``0})">
            <summary>
            Expose the specified {@link Publisher} with the {@link Mono} API, 
            and ensure it will emit 0 or 1 item.
            </summary>
            <typeparam name="T">the source type</typeparam>
            <param name="source">The IPublisher source to convert to IMono.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.From``1(System.Func{``0},System.Boolean)">
            <summary>
            Create a IMono producing the value for the IMono using the given supplier.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="generator">The function to generate a value.</param>
            <param name="nullMeansEmpty">If true and T is a class, returning null
            from the function is interpreted as an empty source.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.From(System.Threading.Tasks.Task)">
            <summary>
            Creates a valueless IMono instance from the task which
            signals when the task completes or fails.
            </summary>
            <param name="task">The tast to use as source.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.From``1(System.Threading.Tasks.Task{``0})">
            <summary>
            Creates a IMono instance from the task which
            signals a single value when the task completes or 
            signals an Exception if the task fails.
            </summary>
            <param name="task">The tast to use as source.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.From``1(System.Action)">
            <summary>
            Executes the given action for each subscriber and completes
            or signals an Exception if the action threw.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="action">The action</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.IgnoreElements``1(Reactive.Streams.IPublisher{``0})">
            <summary>
            Create a new {@link Mono} that ignores onNext (dropping them) and 
            only react on Completion signal.
            </summary>
            <typeparam name="T">The value type of the source.</typeparam>
            <param name="source">The source t ignore values of.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Using``2(System.Func{``1},System.Func{``1,Reactor.Core.IMono{``0}},System.Action{``1},System.Boolean)">
            <summary>
            Uses a resource, generated by a supplier for each individual Subscriber, while
            streaming the value from a Mono derived from the same resource and makes sure 
            the resource is released if the sequence terminates or the Subscriber cancels.
            </summary>
            <typeparam name="T">The main value type</typeparam>
            <typeparam name="R">The resource type.</typeparam>
            <param name="resourceFactory">Called to return a per-subscriber resource.</param>
            <param name="monoFactory">Called with the resource from the resourceFactory
            to generate an IMono instance.</param>
            <param name="resourceDisposer">Called when the generated IMono
            source terminates or the whole sequence gets cancelled.</param>
            <param name="eager">If true, the resourceDisposer is called before
            signalling the terminal event.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.When``2(Reactor.Core.IMono{``0},Reactor.Core.IMono{``1},System.Boolean)">
            <summary>
             Merge given monos into a new a IMono that will be fulfilled 
             when all of the given IMonos have been fulfilled. If delayErrors is false
             any error will cause pending results to be cancelled and immediate error 
             emission  to the returned IMono.
            </summary>
            <typeparam name="T1">type of the value from m1</typeparam>
            <typeparam name="T2">type of the value from m2</typeparam>
            <param name="m1">The first upstream IMono to subscribe to.</param>
            <param name="m2">The second upstream IMono to subscribe to.</param>
            <param name="delayErrors">If true, errors will be delayed till all sources terminate.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.When``3(Reactor.Core.IMono{``0},Reactor.Core.IMono{``1},Reactor.Core.IMono{``2},System.Boolean)">
            <summary>
             Merge given monos into a new a IMono that will be fulfilled 
             when all of the given IMonos have been fulfilled. If delayErrors is false
             any error will cause pending results to be cancelled and immediate error 
             emission  to the returned IMono.
            </summary>
            <typeparam name="T1">type of the value from m1</typeparam>
            <typeparam name="T2">type of the value from m2</typeparam>
            <typeparam name="T3">type of the value from m3</typeparam>
            <param name="m1">The first upstream IMono to subscribe to.</param>
            <param name="m2">The second upstream IMono to subscribe to.</param>
            <param name="m3">The third upstream IMono to subscribe to.</param>
            <param name="delayErrors">If true, errors will be delayed till all sources terminate.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.When``4(Reactor.Core.IMono{``0},Reactor.Core.IMono{``1},Reactor.Core.IMono{``2},Reactor.Core.IMono{``3},System.Boolean)">
            <summary>
             Merge given monos into a new a IMono that will be fulfilled 
             when all of the given IMonos have been fulfilled. If delayErrors is false
             any error will cause pending results to be cancelled and immediate error 
             emission  to the returned IMono.
            </summary>
            <typeparam name="T1">type of the value from m1</typeparam>
            <typeparam name="T2">type of the value from m2</typeparam>
            <typeparam name="T3">type of the value from m3</typeparam>
            <typeparam name="T4">type of the value from m4</typeparam>
            <param name="m1">The first upstream IMono to subscribe to.</param>
            <param name="m2">The second upstream IMono to subscribe to.</param>
            <param name="m3">The third upstream IMono to subscribe to.</param>
            <param name="m4">The fourth upstream IMono to subscribe to.</param>
            <param name="delayErrors">If true, errors will be delayed till all sources terminate.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.When``5(Reactor.Core.IMono{``0},Reactor.Core.IMono{``1},Reactor.Core.IMono{``2},Reactor.Core.IMono{``3},Reactor.Core.IMono{``4},System.Boolean)">
            <summary>
             Merge given monos into a new a IMono that will be fulfilled 
             when all of the given IMonos have been fulfilled. If delayErrors is false
             any error will cause pending results to be cancelled and immediate error 
             emission  to the returned IMono.
            </summary>
            <typeparam name="T1">type of the value from m1</typeparam>
            <typeparam name="T2">type of the value from m2</typeparam>
            <typeparam name="T3">type of the value from m3</typeparam>
            <typeparam name="T4">type of the value from m4</typeparam>
            <typeparam name="T5">type of the value from m5</typeparam>
            <param name="m1">The first upstream IMono to subscribe to.</param>
            <param name="m2">The second upstream IMono to subscribe to.</param>
            <param name="m3">The third upstream IMono to subscribe to.</param>
            <param name="m4">The fourth upstream IMono to subscribe to.</param>
            <param name="m5">The fifth upstream IMono to subscribe to.</param>
            <param name="delayErrors">If true, errors will be delayed till all sources terminate.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.When``6(Reactor.Core.IMono{``0},Reactor.Core.IMono{``1},Reactor.Core.IMono{``2},Reactor.Core.IMono{``3},Reactor.Core.IMono{``4},Reactor.Core.IMono{``5},System.Boolean)">
            <summary>
             Merge given monos into a new a IMono that will be fulfilled 
             when all of the given IMonos have been fulfilled. If delayErrors is false
             any error will cause pending results to be cancelled and immediate error 
             emission  to the returned IMono.
            </summary>
            <typeparam name="T1">type of the value from m1</typeparam>
            <typeparam name="T2">type of the value from m2</typeparam>
            <typeparam name="T3">type of the value from m3</typeparam>
            <typeparam name="T4">type of the value from m4</typeparam>
            <typeparam name="T5">type of the value from m5</typeparam>
            <typeparam name="T6">type of the value from m6</typeparam>
            <param name="m1">The first upstream IMono to subscribe to.</param>
            <param name="m2">The second upstream IMono to subscribe to.</param>
            <param name="m3">The third upstream IMono to subscribe to.</param>
            <param name="m4">The fourth upstream IMono to subscribe to.</param>
            <param name="m5">The fifth upstream IMono to subscribe to.</param>
            <param name="m6">The sixth upstream IMono to subscribe to.</param>
            <param name="delayErrors">If true, errors will be delayed till all sources terminate.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.When``1(System.Boolean,Reactor.Core.IMono{``0}[])">
            <summary>
             Merge given monos into a new a IMono that will be fulfilled 
             when all of the given IMonos have been fulfilled. If delayErrors is false
             any error will cause pending results to be cancelled and immediate error 
             emission  to the returned IMono.
            </summary>
            <typeparam name="T">The common value type of the source IMonos</typeparam>
            <param name="delayErrors">If true, errors will be delayed till all sources terminate.</param>
            <param name="sources">The parameters array IMono sources.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.When``1(System.Collections.Generic.IEnumerable{Reactor.Core.IMono{``0}},System.Boolean)">
            <summary>
             Merge given monos into a new a IMono that will be fulfilled 
             when all of the given IMonos have been fulfilled. If delayErrors is false
             any error will cause pending results to be cancelled and immediate error 
             emission  to the returned IMono.
            </summary>
            <typeparam name="T">The common value type of the source IMonos</typeparam>
            <param name="delayErrors">If true, errors will be delayed till all sources terminate.</param>
            <param name="sources">The IEnumerable sequence of IMono sources.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Zip``2(System.Func{``0[],``1},Reactor.Core.IMono{``0}[])">
            <summary>
            Aggregate given monos into a new a IMono that will be fulfilled 
            when all of the given IMono have been fulfilled. If any Mono 
            terminates without value, the returned sequence will be terminated
            immediately and pending results cancelled.
            </summary>
            <typeparam name="T">The super incoming type</typeparam>
            <typeparam name="R">The type of the function result.</typeparam>
            <param name="zipper">The function that receives a row of elements from
            all source Monos.</param>
            <param name="sources">The parameters array of IMono sources</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Zip``2(System.Collections.Generic.IEnumerable{Reactor.Core.IMono{``0}},System.Func{``0[],``1})">
            <summary>
            Aggregate given monos into a new a IMono that will be fulfilled 
            when all of the given IMono have been fulfilled. If any Mono 
            terminates without value, the returned sequence will be terminated
            immediately and pending results cancelled.
            </summary>
            <typeparam name="T">The super incoming type</typeparam>
            <typeparam name="R">The type of the function result.</typeparam>
            <param name="zipper">The function that receives a row of elements from
            all source Monos.</param>
            <param name="sources">The IEnumerable sequence of IMono sources</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Map``2(Reactor.Core.IMono{``0},System.Func{``0,``1})">
            <summary>
            Transform the items emitted by this IFlux by applying a function to each item.
            </summary>
            <typeparam name="T">The input value type</typeparam>
            <typeparam name="R">The output value type</typeparam>
            <param name="source">The source IFlux</param>
            <param name="mapper">The mapper from Ts to Rs</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.As``2(Reactor.Core.IMono{``0},System.Func{Reactor.Core.IMono{``0},``1})">
            <summary>
            Transform this IMono into a target type.
            </summary>
            <typeparam name="T">The source value type</typeparam>
            <typeparam name="R">The result type</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="transformer">The function called with the source IMono
            and returns a value.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.And``2(Reactor.Core.IMono{``0},Reactor.Core.IMono{``1})">
            <summary>
            Combine the result from this mono and another into a Tuple.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="U">The other value type.</typeparam>
            <param name="source">The main source IMono instance.</param>
            <param name="other">The other source IMono instance.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Cast``2(Reactor.Core.IMono{``0})">
            <summary>
            Cast the current IMono produced type into a target produced type.
            </summary>
            <typeparam name="T">The source IMono value type.</typeparam>
            <typeparam name="R">The result IMono value type.</typeparam>
            <param name="source">The source IMono instance to cast elements of.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Cache``1(Reactor.Core.IMono{``0})">
            <summary>
            Turn this IMono into a hot source and cache last emitted
            signals for further ISubscriber.
            Completion and Error will also be replayed.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance to cache its signal.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Compose``2(Reactor.Core.IMono{``0},System.Func{Reactor.Core.IMono{``0},Reactor.Core.IMono{``1}})">
            <summary>
            Defer the given transformation to this IMono in order to generate a
            target IMono type. A transformation will occur for each ISubscriber.
            </summary>
            <typeparam name="T">The source value type</typeparam>
            <typeparam name="R">The output value type</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="composer">The function that receives the source IMono
            and returns another IMono instance for each individual ISubscriber.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.ConcatWith``1(Reactor.Core.IMono{``0},Reactive.Streams.IPublisher{``0},System.Boolean)">
            <summary>
            Concatenate emissions of this IMono with the provided IPublisher
            (no interleave).
            </summary>
            <typeparam name="T">The value type</typeparam>
            <param name="source">The beginning IMono instance</param>
            <param name="other">The ending IMono instance</param>
            <param name="delayErrors">If true, errors from the first source
            instance is delayed until the second IMono terminates.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.DefaultIfEmpty``1(Reactor.Core.IMono{``0},``0)">
            <summary>
            Provide a default unique value if this mono is completed without any data.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="defaultValue">the alternate value if the source is empty</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.DelaySubscription``1(Reactor.Core.IMono{``0},System.TimeSpan)">
            <summary>
            Delay the subscription to this IMono source until the given period elapses.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="delay">The delay amount before subscribing to the source IMono.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.DelaySubscription``1(Reactor.Core.IMono{``0},System.TimeSpan,Reactor.Core.TimedScheduler)">
            <summary>
            Delay the subscription to this IMono source until the given period elapses.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="delay">The delay amount before subscribing to the source IMono.</param>
            <param name="scheduler">The timed scheduler to use for waiting.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.DelaySubscription``2(Reactor.Core.IMono{``0},Reactive.Streams.IPublisher{``1})">
            <summary>
            Delay the subscription to this {@link Mono} until another {@link Publisher}
            signals a value or completes.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="U">The other value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="other">The other IPublisher instance that when signals
            or completes, triggers the actual subscription to the source IMono.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Dematerialize``1(Reactor.Core.IMono{Reactor.Core.ISignal{``0}})">
            <summary>
            Calls the appropriate OnXXX method on the ISubscriber based on the
            source ISignal's contents.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.DoAfterTerminate``1(Reactor.Core.IMono{``0},System.Action)">
            <summary>
            Call the specified action after the source has signalled an OnError or OnComplete.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono.</param>
            <param name="onAfterTerminate">The action to call.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.DoAfterNext``1(Reactor.Core.IMono{``0},System.Action{``0})">
            <summary>
            Call the specified action with the current value after the source has signalled an OnNext.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono.</param>
            <param name="onAfterNext">The action to call.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.DoOnCancel``1(Reactor.Core.IMono{``0},System.Action)">
            <summary>
            Call the specified action if the sequence gets cancelled.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono.</param>
            <param name="onCancel">The action to call.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.DoOnComplete``1(Reactor.Core.IMono{``0},System.Action)">
            <summary>
            Call the specified action before the source signals an OnComplete.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono.</param>
            <param name="onComplete">The action to call.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.DoOnError``1(Reactor.Core.IMono{``0},System.Action{System.Exception})">
            <summary>
            Call the specified action before the source signals an OnError.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono.</param>
            <param name="onError">The action to call.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.DoOnError``2(Reactor.Core.IMono{``0},System.Action{``1})">
            <summary>
            Call the specified action before the source signals OnError with the given Exception type (or its subtypes).
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <typeparam name="E">The exception type.</typeparam>
            <param name="source">The source IMono.</param>
            <param name="onError">The action to call.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.DoOnError``1(Reactor.Core.IMono{``0},System.Func{System.Exception,System.Boolean},System.Action{System.Exception})">
            <summary>
            Call the specified action before the source signals an OnError whose Exception matches the predicate.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono.</param>
            <param name="predicate">The predicate that receives the Exception and if returns true, the onError action is called.</param>
            <param name="onError">The action to call.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.DoOnNext``1(Reactor.Core.IMono{``0},System.Action{``0})">
            <summary>
            Calls the specified action with the current value before the sequence signals an OnNext.
            </summary>
            <typeparam name="T">The value type</typeparam>
            <param name="source">The source IMono</param>
            <param name="onNext">The action to call with the current value.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.DoOnRequest``1(Reactor.Core.IMono{``0},System.Action{System.Int64})">
            <summary>
            Calls the specified action with the current request amount before it reaches the upstream.
            </summary>
            <typeparam name="T">The value type</typeparam>
            <param name="source">The source IMono</param>
            <param name="onRequest">The action to call.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.DoOnSubscribe``1(Reactor.Core.IMono{``0},System.Action{Reactive.Streams.ISubscription})">
            <summary>
            Calls the specified action with the incoming ISubscription before it reaches the downstream.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono.</param>
            <param name="onSubscribe">The action to call.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.DoOnTerminate``1(Reactor.Core.IMono{``0},System.Action)">
            <summary>
            Calls the specified action befoer the source signals an OnError or OnComplete.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono.</param>
            <param name="onTerminate">The action to call.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Elapsed``1(Reactor.Core.IMono{``0})">
            <summary>
            Wraps each source element into a Timed structure which holds the time difference between
            subsequent element according to the default timed scheduler. The first structure holds
            the time between the subscription and the emission of the first element.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Elapsed``1(Reactor.Core.IMono{``0},Reactor.Core.TimedScheduler)">
            <summary>
            Wraps each source element into a Timed structure which holds the time difference between
            subsequent element according to the given timed scheduler. The first structure holds
            the time between the subscription and the emission of the first element.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono.</param>
            <param name="scheduler">The scheduler supplying the notion of current time.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Filter``1(Reactor.Core.IMono{``0},System.Func{``0,System.Boolean})">
            <summary>
            Filters out elements that don't match the predicate.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono</param>
            <param name="predicate">The predicate function called for each source element and returns true if that element
            may pass.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.FlatMap``2(Reactor.Core.IMono{``0},System.Func{``0,Reactive.Streams.IPublisher{``1}})">
            <summary>
            Transform the items emitted by the IMono into an IPublisher, then 
            flattens the emissions from this IPublisher by merging them into a single 
            IFlux.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="R">the merged sequence type</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="mapper">The function that receives the Mono's single
            value (if any) and returns an IPublisher whose value will be relayed
            then on.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.FlatMap``2(Reactor.Core.IMono{``0},System.Func{``0,Reactor.Core.IMono{``1}})">
            <summary>
            Transform the items emitted by the IMono into an IMono, then 
            signals the emission of this IMono.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="R">the merged sequence type</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="mapper">The function that receives the Mono's single
            value (if any) and returns an IMono whose signal will be relayed
            then on.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.FlatMap``2(Reactor.Core.IMono{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Transform the items emitted by the IMono into an IEnumerable, then 
            signals the values of this IEnumerable through the resulting IFlux.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="R">the merged sequence type</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="mapper">The function that receives the Mono's single
            value (if any) and returns an IEnumerable whose value will be relayed
            then on.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.FlatMap``2(Reactor.Core.IMono{``0},System.Func{``0,Reactive.Streams.IPublisher{``1}},System.Func{System.Exception,Reactive.Streams.IPublisher{``1}},System.Func{Reactive.Streams.IPublisher{``1}})">
            <summary>
            Based on the signal of the source IMono, continues relaying
            the values of an IPublisher returned by the appropriate signal
            mapper function.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="R">The result value type.</typeparam>
            <param name="source">The source IMono sequence.</param>
            <param name="onNextMapper">Function called with the value of the source
            IMono and returns an IPublisher to be signal elements from then on.</param>
            <param name="onErrorMapper">Function called with the Exception of the source
            IMono and returns an IPublisher to be signal elements from then on.</param>
            <param name="onCompleteMapper">Function called when the source
            IMono completes and returns an IPublisher to be signal elements 
            from then on.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.ToFlux``1(Reactor.Core.IMono{``0})">
            <summary>
            Converts this IMono into an IFlux.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source to convert</param>
            <returns>The new IFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.Mono.HasElement``1(Reactor.Core.IMono{``0})">
            <summary>
            Emit a single boolean true if this IMono has an element.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Hide``1(Reactor.Core.IMono{``0})">
            <summary>
            Hides the identity of the source IMono, including its
            ISubscription. Prevents fusion optimizations.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source iMono instance.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.IgnoreElement``1(Reactor.Core.IMono{``0})">
            <summary>
            Ignores onNext signal (dropping it) and only reacts on termination.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source iMono instance.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.MapError``1(Reactor.Core.IMono{``0},System.Func{System.Exception,System.Exception})">
            <summary>
            Maps the Exception in the OnError signal via a mapper function.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono.</param>
            <param name="mapper">The function that receives the Exception from the source and returns an Exception in exchange.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.MapError``2(Reactor.Core.IMono{``0},System.Func{``1,System.Exception})">
            <summary>
            Maps the Exception in the OnError signal, if it is of the specified type, via a mapper function.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <typeparam name="E">The Exception type to map.</typeparam>
            <param name="source">The source IMono.</param>
            <param name="mapper">The function that is called if the upstream Exception is of the specified 
            type and returns an Exception in exchange.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.MapError``1(Reactor.Core.IMono{``0},System.Func{System.Exception,System.Boolean},System.Func{System.Exception,System.Exception})">
            <summary>
            Maps the Exception in the OnError signal, if it matches a predicate, via a mapper function.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="predicate">The predicate called with the upstream Exception and if returns true, the <paramref name="mapper"/> is called.</param>
            <param name="mapper">The function called with the upstream Exception, if the predicate matched, and returns an Exception in exchange.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Materialize``1(Reactor.Core.IMono{``0})">
            <summary>
            Transform the incoming onNext, onError and onComplete signals into ISignal.
            Since the error is materialized as a {@code Signal}, the propagation will
            be stopped and onComplete will be mitted. Complete signal will first emit
            a {@code Signal.complete()} and then effectively complete the flux.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.MergeWith``1(Reactor.Core.IMono{``0},Reactive.Streams.IPublisher{``0})">
            <summary>
            Merge emissions of this {@link Mono} with the provided IPublisher.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="other">The other IPublisher instance.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Nest``1(Reactor.Core.IMono{``0})">
            <summary>
            Emit the current instance of the IMono.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Or``1(Reactor.Core.IMono{``0},Reactor.Core.IMono{``0})">
            <summary>
            Emit the any of the result from this mono or from the given mono.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="other">The other IMono instance</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Otherwise``1(Reactor.Core.IMono{``0},Reactor.Core.IMono{``0})">
            <summary>
            Subscribe to a returned fallback publisher when any error occurs.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="fallback">The fallback IMono instance.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Otherwise``2(Reactor.Core.IMono{``0},System.Func{``1,Reactor.Core.IMono{``0}})">
            <summary>
            Subscribe to a returned fallback publisher when an error matching 
            the given type occurs.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <typeparam name="E">The exception type to react to</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="resumeFunction">The function that receives the given
            exception type and returns an IMono instance to resume with.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Otherwise``1(Reactor.Core.IMono{``0},System.Func{System.Exception,Reactor.Core.IMono{``0}})">
            <summary>
            Subscribe to a returned fallback publisher when an error matching 
            the given type occurs.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="resumeFunction">The function that receives the
            exception type and returns an IMono instance to resume with.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.OtherwiseIfEmpty``1(Reactor.Core.IMono{``0},Reactor.Core.IMono{``0})">
            <summary>
            Provide an alternative IMono if this mono is completed without data.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="other">The alternative IMono instance.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.OtherwiseReturn``1(Reactor.Core.IMono{``0},``0)">
            <summary>
            Subscribe to a returned fallback value when any error occurs.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="value">The fallback value to signal if the 
            source terminated with any error.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.OtherwiseReturn``2(Reactor.Core.IMono{``0},``0)">
            <summary>
            Fallback to the given value if an error of a given type is observed on this
            IMono.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <typeparam name="E">The exception type to react to.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="value">The fallback value to signal if the 
            source terminated with the specified class of exception error.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.OtherwiseReturn``1(Reactor.Core.IMono{``0},System.Func{System.Exception,System.Boolean},``0)">
            <summary>
            Fallback to the given value if an error matching the given predicate is
            observed on this IMono.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="predicate">The predicate receiving the exception from
            the source and returns true if the fallback value should be used.</param>
            <param name="value">The fallback value to signal if the 
            source terminated with an exception that matches the predicate.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.OnTerminateDetach``1(Reactor.Core.IMono{``0})">
            <summary>
            Detaches the references between the upstream and downstream (the upstreams ISubscription
            and the downstreams ISubscriber), allowing both to be garbage collected early.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Publish``2(Reactor.Core.IMono{``0},System.Func{Reactor.Core.IMono{``0},Reactor.Core.IMono{``1}})">
            <summary>
            Shares a IMono for the duration of a function that may transform it and
            consume it as many times as necessary without causing multiple subscriptions
            to the upstream.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <typeparam name="R">The result value type</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="transformer">The function that receives a shared
            IMono instance and returns another IMono instance to
            be subscribed by the downstream.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.PublishOn``1(Reactor.Core.IMono{``0},Reactor.Core.Scheduler)">
            <summary>
            Run onNext, onComplete and onError on a supplied Scheduler.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="scheduler">The target scheduler where t exectute the
            OnNext, OnError and OnComplete methods.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Repeat``1(Reactor.Core.IMono{``0})">
            <summary>
            Repeatedly subscribe to the source completion of the previous subscription.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Repeat``1(Reactor.Core.IMono{``0},System.Int64)">
            <summary>
            Repeatedly subscribe to the source at most the given number of times.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="times">The number of times to subscribe to the source in
            total.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Repeat``1(Reactor.Core.IMono{``0},System.Func{System.Boolean})">
            <summary>
            Repeatedly subscribe to the source if the predicate returns true after 
            completion of the previous subscription.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="predicate">The preducate to return true to subscribe
            to the source again.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Repeat``1(Reactor.Core.IMono{``0},System.Int64,System.Func{System.Boolean})">
            <summary>
            Repeatedly subscribe to the source if the predicate returns true after 
            completion of the subscription. A specified maximum of repeat will 
            limit the number of re-subscribe.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="times">The number of times to subscribe to the source in
            total.</param>
            <param name="predicate">The preducate to return true to subscribe
            to the source again.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.RepeatWhen``1(Reactor.Core.IMono{``0},System.Func{Reactor.Core.IFlux{System.Int64},Reactive.Streams.IPublisher{System.Object}})">
            <summary>
            Repeatedly subscribe to this IMono when a companion sequence 
            signals a number of emitted elements in response to the flux completion 
            signal.
            If the companion sequence signals when this IMono is active, the 
            repeat attempt is suppressed and any terminal signal will terminate
            this IFlux with the same signal immediately.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="whenFunction">The function providing a IFlux 
            signalling an exclusive number of emitted elements on onComplete and 
            returning a IPublisher companion.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.RepeatWhenEmpty``1(Reactor.Core.IMono{``0},System.Func{Reactor.Core.IFlux{System.Int64},Reactive.Streams.IPublisher{System.Object}})">
            <summary>
            Repeatedly subscribe to this IMono until there is an onNext signal 
            when a companion sequence signals a number of emitted elements.
            If the companion sequence signals when this IMono is active, the repeat
            attempt is suppressed and any terminal signal will terminate this IMono 
            with the same signal immediately.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="whenFunction">The function providing a IFlux 
            signalling an exclusive number of emitted elements on onComplete and 
            returning a IPublisher companion.</param>
            <returns>The new Mono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.RepeatWhenEmpty``1(Reactor.Core.IMono{``0},System.Int64,System.Func{Reactor.Core.IFlux{System.Int64},Reactive.Streams.IPublisher{System.Object}})">
            <summary>
            Repeatedly subscribe to this IMono until there is an onNext signal 
            when a companion sequence signals a number of emitted elements.
            If the companion sequence signals when this IMono is active, the repeat
            attempt is suppressed and any terminal signal will terminate this IMono 
            with the same signal immediately.
            Emits an InvalidOperationException if the max 
            repeat is exceeded and different from <see cref="F:System.Int32.MaxValue"/>.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="times"> the maximum repeat number of time (infinite if 
            <see cref="F:System.Int32.MaxValue"/>).</param>
            <param name="whenFunction">The function providing a IFlux 
            signalling an exclusive number of emitted elements on onComplete and 
            returning a IPublisher companion.</param>
            <returns>The new Mono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Retry``1(Reactor.Core.IMono{``0})">
            <summary>
            Re-subscribes to this IMono sequence if it signals any error
            indefinitely
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <returns>The new Mono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Retry``1(Reactor.Core.IMono{``0},System.Int64)">
            <summary>
            Re-subscribes to this IMono sequence if it signals any error
            either indefinitely or a fixed number of times.
            The times == <see cref="F:System.Int32.MaxValue"/> is treated as infinite retry.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="times">the number of times to tolerate an error</param>
            <returns>The new Mono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Retry``1(Reactor.Core.IMono{``0},System.Func{System.Exception})">
            <summary>
            e-subscribes to this IMono sequence if it signals any error
            and the given predicate matches otherwise push the error downstream.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="predicate">the predicate to evaluate if retry should
            occur based on a given error signal</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Retry``1(Reactor.Core.IMono{``0},System.Int64,System.Func{System.Exception})">
            <summary>
            Re-subscribes to this IMono sequence up to the specified
            number of retries if it signals any error and the given 
            predicate matches otherwise push the error downstream.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="times">the number of times to tolerate an error</param>
            <param name="predicate">the predicate to evaluate if retry should
            occur based on a given error signal</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.RetryWhen``1(Reactor.Core.IMono{``0},System.Func{Reactor.Core.IFlux{System.Exception},Reactive.Streams.IPublisher{System.Object}})">
            <summary>
            Retries this {@link Mono} when a companion sequence signals
            an item in response to this {@link Mono} error signal.
            If the companion sequence signals when the {@link Mono} is 
            active, the retry attempt is suppressed and any terminal signal 
            will terminate the IMono source with the same signal immediately.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="whenFunction">the function providing a 
            IFlux signalling any error from the source sequence and 
            returning a IPublisher companion.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.SubscribeOn``1(Reactor.Core.IMono{``0},Reactor.Core.Scheduler)">
            <summary>
            Run the requests to this IMono on a given worker assigned by the 
            supplied Scheduler.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="scheduler">The target scheduler to subscribe on and
            emit signals when requested.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Then``1(Reactor.Core.IMono{``0})">
            <summary>
            Return a IMono of Void which only listens for complete and error 
            signals from this IMono completes.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Then``2(Reactor.Core.IMono{``0},System.Func{``0,Reactor.Core.IMono{``1}})">
            <summary>
             Convert the value of IMono to another IMono
             possibly with another value type.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <typeparam name="R">The result value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="transformer">the function to dynamically bind a new IMono</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Then``2(Reactor.Core.IMono{``0},Reactor.Core.IMono{``1})">
            <summary>
            Transform the terminal signal (error or completion) into IMono
            that will emit at most one result in the returned IMono.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <typeparam name="R">The result value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="other">a IMono to emit from after termination</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Then``2(Reactor.Core.IMono{``0},System.Func{Reactor.Core.IMono{``1}})">
            <summary>
            Transform the terminal signal (error or completion) into IMono
            that will emit at most one result in the returned IMono. 
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <typeparam name="R">The result value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="other">The function to generate a IMono to emit from after 
            termination for each subscriber.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.ThenMany``2(Reactor.Core.IMono{``0},Reactive.Streams.IPublisher{``1})">
            <summary>
            Transform the terminal signal (error or completion) into 
            IPublisher that will emit at most one result in the
            returned IFlux.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <typeparam name="R">The result value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="other">The other IPublisher instance to relay signals
            after the source completed.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.ThenMany``2(Reactor.Core.IMono{``0},System.Func{Reactive.Streams.IPublisher{``1}})">
            <summary>
            Transform the terminal signal (error or completion) into 
            IPublisher that will emit at most one result in the returned IFlux.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <typeparam name="R">The result value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="other">The function to generate a IPublisher to emit from after 
            termination for each subscriber.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Timeout``1(Reactor.Core.IMono{``0},System.TimeSpan,Reactor.Core.IMono{``0})">
            <summary>
            Signal a TimeoutException error 
            in case an item doesn't arrive before the given period.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="timeout">The time to wait before switching to the
            fallback IMono or signalling a TimeoutException.</param>
            <param name="fallback">If not null, a timeout switches to
            this IMono instance.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Timeout``1(Reactor.Core.IMono{``0},System.TimeSpan,Reactor.Core.TimedScheduler,Reactor.Core.IMono{``0})">
            <summary>
            Signal a TimeoutException error in case an item doesn't arrive before 
            the given period, run on the specified timed scheduler.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="timeout">The time to wait before switching to the
            fallback IMono or signalling a TimeoutException.</param>
            <param name="scheduler">The scheduler to await the first value.</param>
            <param name="fallback">If not null, a timeout switches to
            this IMono instance.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Timeout``2(Reactor.Core.IMono{``0},Reactive.Streams.IPublisher{``1},Reactor.Core.IMono{``0})">
            <summary>
            Signal a TimeoutException in case the 
            item from this IMono has  not been emitted before the given
            IPublisher emits.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <typeparam name="U">The timeout IPublisher value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="firstTimeout">the timeout IPublisher that must not 
            emit before the first signal from this IMono.</param>
            <param name="fallback">If not null, a timeout switches to
            this IMono instance.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Timestamp``1(Reactor.Core.IMono{``0})">
            <summary>
            Emit a Timed record with the current system time in millis
            the associated data from the source IMono if any.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Timestamp``1(Reactor.Core.IMono{``0},Reactor.Core.TimedScheduler)">
            <summary>
            Emit a Timed record with the current system time in millis
            the associated data from the source IMono if any as
            determined by the given timed scheduler.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="scheduler">The timed scheduler for the notion of current
            time.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.ToObservable``1(Reactor.Core.IMono{``0})">
            <summary>
            Convert this IMono into an IObservable.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono.</param>
            <returns>The new IObservable.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Block``1(Reactor.Core.IMono{``0})">
            <summary>
            Subscribe to the source and block until it produces a value or
            signals an Exception. An empty source will throw an IndexOutOfRangeException.
            </summary>
            <typeparam name="T">The value type</typeparam>
            <param name="source">The source</param>
            <returns>The value produced</returns>
            <exception cref="T:System.IndexOutOfRangeException">If the source is empty.</exception>
        </member>
        <member name="M:Reactor.Core.Mono.Block``1(Reactor.Core.IMono{``0},System.TimeSpan)">
            <summary>
            Subscribe to the source and block until it produces a value or
            signals an Exception. An empty source will throw an IndexOutOfRangeException.
            </summary>
            <typeparam name="T">The value type</typeparam>
            <param name="source">The source</param>
            <param name="timeout">The maximum amount of time to wait for the value.</param>
            <returns>The value produced</returns>
            <exception cref="T:System.IndexOutOfRangeException">If the source is empty.</exception>
            <exception cref="T:System.TimeoutException">If the source didn't produce any value within the given timeout.</exception>
        </member>
        <member name="M:Reactor.Core.Mono.Subscribe``1(Reactor.Core.IMono{``0})">
            <summary>
            Subscribes to the IPublisher and ignores all of its signals.
            </summary>
            <typeparam name="T">The value type</typeparam>
            <param name="source">The source IPublisher</param>
            <returns>The IDisposable that allows cancelling the subscription.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Subscribe``1(Reactor.Core.IMono{``0},System.Action{``0})">
            <summary>
            Subscribes to the IPublisher and consumes only its OnNext signals.
            </summary>
            <typeparam name="T">The value type</typeparam>
            <param name="source">The source IPublisher</param>
            <param name="onNext">The callback for the OnNext signals</param>
            <returns>The IDisposable that allows cancelling the subscription.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Subscribe``1(Reactor.Core.IMono{``0},System.Action{``0},System.Action{System.Exception})">
            <summary>
            Subscribes to the IPublisher and consumes only its OnNext signals.
            </summary>
            <remarks>
            If the <paramref name="onNext"/> callback crashes, the error is routed
            to <paramref name="onError"/> callback.
            If the <paramref name="onError"/> callback crashes, the error is routed to the
            global error hanlder in <see cref="M:Reactor.Core.ExceptionHelper.OnErrorDropped(System.Exception)"/>.
            </remarks>
            <typeparam name="T">The value type</typeparam>
            <param name="source">The source IPublisher</param>
            <param name="onNext">The callback for the OnNext signals</param>
            <param name="onError">The callback for the OnError signals</param>
            <returns>The IDisposable that allows cancelling the subscription.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Subscribe``1(Reactor.Core.IMono{``0},System.Action{``0},System.Action{System.Exception},System.Action)">
            <summary>
            Subscribes to the IPublisher and consumes only its OnNext signals.
            </summary>
            <remarks>
            If the <paramref name="onNext"/> callback crashes, the error is routed
            to <paramref name="onError"/> callback.
            If the <paramref name="onError"/> or <paramref name="onComplete"/> callbackcrashes, 
            the error is routed to the
            global error hanlder in <see cref="M:Reactor.Core.ExceptionHelper.OnErrorDropped(System.Exception)"/>.
            </remarks>
            <typeparam name="T">The value type</typeparam>
            <param name="source">The source IPublisher</param>
            <param name="onNext">The callback for the OnNext signals.</param>
            <param name="onError">The callback for the OnError signal.</param>
            <param name="onComplete">The callback for the OnComplete signal.</param>
            <returns>The IDisposable that allows cancelling the subscription.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.SubscribeWith``2(Reactor.Core.IMono{``0},``1)">
            <summary>
            Subscribes to the source IMono with the ISubscriber instance
            and returns it.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="E">The type of the ISubscriber.</typeparam>
            <param name="source">The source IMono instance.</param>
            <param name="subscriber">The subscriber to subscribe with to the IMono source.</param>
            <returns>The input ISubscriber instance</returns>
        </member>
        <member name="M:Reactor.Core.Mono.ToEnumerable``1(Reactor.Core.IMono{``0})">
            <summary>
            Convert the source IMono into a blocking enumerable that
            signals the value or error from the given IMono.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <param name="source">The source IMono instance.</param>
            <returns>The new IEnumerable instance.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.ToTask``1(Reactor.Core.IMono{``0})">
            <summary>
            Returns a Task that awaits a single item from the IMono or
            signals an IndexOutOfRangeException if the IMono is empty.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono</param>
            <returns>The task.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.ToTask``1(Reactor.Core.IMono{``0},System.Threading.CancellationToken)">
            <summary>
            Returns a Task that awaits a single item from the IMono or
            signals an IndexOutOfRangeException if the IMono is empty.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IMono</param>
            <param name="ct">The cancellation token.</param>
            <returns>The task.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.WhenCompleteTask``1(Reactor.Core.IMono{``0})">
            <summary>
            Return a Task that waits for the IMono source to complete.
            </summary>
            <param name="source">The source IMono</param>
            <returns>The task.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.WhenCompleteTask``1(Reactor.Core.IMono{``0},System.Threading.CancellationToken)">
            <summary>
            Return a Task that waits for the IMono source to complete
            and support the cancellation of such wait.
            </summary>
            <param name="source">The source IMono</param>
            <param name="ct">The cancellation token.</param>
            <returns>The task.</returns>
        </member>
        <member name="M:Reactor.Core.Mono.Test``1(Reactor.Core.IMono{``0},System.Int64,System.Int32,System.Boolean)">
            <summary>
            Creates a TestSubscriber with the given initial settings and returns it.
            </summary>
            <typeparam name="T">The value type received.</typeparam>
            <param name="source">The source IMono</param>
            <param name="initialRequest">The optional initial request amount.</param>
            <param name="fusionMode">The optional fusion mode if supported by the source.</param>
            <param name="cancelled">Optionally start out as cancelled.</param>
            <returns></returns>
        </member>
        <member name="T:Reactor.Core.Flux">
            <summary>
            Extension methods for IFlux sources.
            </summary>
        </member>
        <member name="P:Reactor.Core.Flux.BufferSize">
            <summary>
            The default buffer size and prefetch amount.
            </summary>
        </member>
        <member name="M:Reactor.Core.Flux.Just``1(``0)">
            <summary>
            Create a new IPublisher that will only emit the passed data then onComplete.
            </summary>
            <typeparam name="T">The value type</typeparam>
            <param name="value">The unique data to emit</param>
            <returns>The new IPublisher instance</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Empty``1">
            <summary>
            Returns an empty instance which completes the ISubscribers immediately.
            </summary>
            <typeparam name="T">The value type</typeparam>
            <returns>The shared Empty instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Never``1">
            <summary>
            Returns an never instance which sets an empty ISubscription and
            does nothing further.
            </summary>
            <typeparam name="T">The value type</typeparam>
            <returns>The shared Never instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.CombineLatest``2(System.Func{``0[],``1},System.Boolean,Reactive.Streams.IPublisher{``0}[])">
            <summary>
            Build a IFlux whose data are generated by the combination of the most recent published values from all
            publishers.
            </summary>
            <remarks>
            Marble diagram:
            https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/combinelatest.png
            </remarks>
            <typeparam name="T">The input value type.</typeparam>
            <typeparam name="R">The output value type.</typeparam>
            <param name="combiner">The function that will receive the latest values from all sources and has to produce an output value.</param>
            <param name="delayError">If true, errors are delayed until all all source IPublishers have terminated.
            If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
            Exceptions</param>
            <param name="sources">The input IPublisher sources.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.CombineLatest``2(System.Func{``0[],``1},System.Int32,System.Boolean,Reactive.Streams.IPublisher{``0}[])">
            <summary>
            Build a IFlux whose data are generated by the combination of the most recent published values from all
            publishers.
            </summary>
            <remarks>
            Marble diagram:
            https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/combinelatest.png
            </remarks>
            <typeparam name="T">The input value type.</typeparam>
            <typeparam name="R">The output value type.</typeparam>
            <param name="combiner">The function that will receive the latest values from all sources and has to produce an output value.</param>
            <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
            unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
            <param name="delayError">If true, errors are delayed until all all source IPublishers have terminated.
            If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
            Exceptions</param>
            <param name="sources">The input IPublisher sources.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Box``1(Reactive.Streams.IPublisher{``0})">
            <summary>
            Boxes or casts a value to object.
            </summary>
            <typeparam name="T">The input value type</typeparam>
            <param name="source">The source IPublisher</param>
            <returns>The IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.CombineLatest``3(Reactive.Streams.IPublisher{``0},Reactive.Streams.IPublisher{``1},System.Func{``0,``1,``2},System.Boolean)">
            <summary>
            Build a IFlux whose data are generated by the combination of the most recent published values from all
            publishers.
            </summary>
            <remarks>
            Marble diagram:
            https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/combinelatest.png
            </remarks>
            <typeparam name="T1">The first source's value type.</typeparam>
            <typeparam name="T2">The second source's value type.</typeparam>
            <typeparam name="R">The output value type.</typeparam>
            <param name="combiner">The function that will receive the latest values from all sources and has to produce an output value.</param>
            <param name="delayError">If true, errors are delayed until all all source IPublishers have terminated.
            If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
            Exceptions</param>
            <param name="p1">The first source.</param>
            <param name="p2">The second source.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.CombineLatest``4(Reactive.Streams.IPublisher{``0},Reactive.Streams.IPublisher{``1},Reactive.Streams.IPublisher{``2},System.Func{``0,``1,``2,``3},System.Boolean)">
            <summary>
            Build a IFlux whose data are generated by the combination of the most recent published values from all
            publishers.
            </summary>
            <remarks>
            Marble diagram:
            https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/combinelatest.png
            </remarks>
            <typeparam name="T1">The first source's value type.</typeparam>
            <typeparam name="T2">The second source's value type.</typeparam>
            <typeparam name="T3">The third source's value type.</typeparam>
            <typeparam name="R">The output value type.</typeparam>
            <param name="combiner">The function that will receive the latest values from all sources and has to produce an output value.</param>
            <param name="delayError">If true, errors are delayed until all all source IPublishers have terminated.
            If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
            Exceptions</param>
            <param name="p1">The first source.</param>
            <param name="p2">The second source.</param>
            <param name="p3">The third source.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.CombineLatest``5(Reactive.Streams.IPublisher{``0},Reactive.Streams.IPublisher{``1},Reactive.Streams.IPublisher{``2},Reactive.Streams.IPublisher{``3},System.Func{``0,``1,``2,``3,``4},System.Boolean)">
            <summary>
            Build a IFlux whose data are generated by the combination of the most recent published values from all
            publishers.
            </summary>
            <remarks>
            Marble diagram:
            https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/combinelatest.png
            </remarks>
            <typeparam name="T1">The first source's value type.</typeparam>
            <typeparam name="T2">The second source's value type.</typeparam>
            <typeparam name="T3">The third source's value type.</typeparam>
            <typeparam name="T4">The fourth source's value type.</typeparam>
            <typeparam name="R">The output value type.</typeparam>
            <param name="combiner">The function that will receive the latest values from all sources and has to produce an output value.</param>
            <param name="delayError">If true, errors are delayed until all all source IPublishers have terminated.
            If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
            Exceptions</param>
            <param name="p1">The first source.</param>
            <param name="p2">The second source.</param>
            <param name="p3">The third source.</param>
            <param name="p4">The fourth source.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.CombineLatest``6(Reactive.Streams.IPublisher{``0},Reactive.Streams.IPublisher{``1},Reactive.Streams.IPublisher{``2},Reactive.Streams.IPublisher{``3},Reactive.Streams.IPublisher{``4},System.Func{``0,``1,``2,``3,``4,``5},System.Boolean)">
            <summary>
            Build a IFlux whose data are generated by the combination of the most recent published values from all
            publishers.
            </summary>
            <remarks>
            Marble diagram:
            https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/combinelatest.png
            </remarks>
            <typeparam name="T1">The first source's value type.</typeparam>
            <typeparam name="T2">The second source's value type.</typeparam>
            <typeparam name="T3">The third source's value type.</typeparam>
            <typeparam name="T4">The fourth source's value type.</typeparam>
            <typeparam name="T5">The fifth source's value type.</typeparam>
            <typeparam name="R">The output value type.</typeparam>
            <param name="combiner">The function that will receive the latest values from all sources and has to produce an output value.</param>
            <param name="delayError">If true, errors are delayed until all all source IPublishers have terminated.
            If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
            Exceptions</param>
            <param name="p1">The first source.</param>
            <param name="p2">The second source.</param>
            <param name="p3">The third source.</param>
            <param name="p4">The fourth source.</param>
            <param name="p5">The fifth source.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.CombineLatest``7(Reactive.Streams.IPublisher{``0},Reactive.Streams.IPublisher{``1},Reactive.Streams.IPublisher{``2},Reactive.Streams.IPublisher{``3},Reactive.Streams.IPublisher{``4},Reactive.Streams.IPublisher{``5},System.Func{``0,``1,``2,``3,``4,``5,``6},System.Boolean)">
            <summary>
            Build a IFlux whose data are generated by the combination of the most recent published values from all
            publishers.
            </summary>
            <remarks>
            Marble diagram:
            https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/combinelatest.png
            </remarks>
            <typeparam name="T1">The first source's value type.</typeparam>
            <typeparam name="T2">The second source's value type.</typeparam>
            <typeparam name="T3">The third source's value type.</typeparam>
            <typeparam name="T4">The fourth source's value type.</typeparam>
            <typeparam name="T5">The fifth source's value type.</typeparam>
            <typeparam name="T6">The sixth source's value type.</typeparam>
            <typeparam name="R">The output value type.</typeparam>
            <param name="combiner">The function that will receive the latest values from all sources and has to produce an output value.</param>
            <param name="delayError">If true, errors are delayed until all all source IPublishers have terminated.
            If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
            Exceptions</param>
            <param name="p1">The first source.</param>
            <param name="p2">The second source.</param>
            <param name="p3">The third source.</param>
            <param name="p4">The fourth source.</param>
            <param name="p5">The fifth source.</param>
            <param name="p6">The sixth source.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.CombineLatest``2(System.Collections.Generic.IEnumerable{Reactive.Streams.IPublisher{``0}},System.Func{``0[],``1},System.Boolean)">
            <summary>
            Build a IFlux whose data are generated by the combination of the most recent published values from all
            publishers.
            </summary>
            <remarks>
            Marble diagram:
            https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/combinelatest.png
            </remarks>
            <typeparam name="T">The input value type.</typeparam>
            <typeparam name="R">The output value type.</typeparam>
            <param name="combiner">The function that will receive the latest values from all sources and has to produce an output value.</param>
            <param name="delayError">If true, errors are delayed until all all source IPublishers have terminated.
            If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
            Exceptions</param>
            <param name="sources">The input IPublisher sources.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.CombineLatest``2(System.Collections.Generic.IEnumerable{Reactive.Streams.IPublisher{``0}},System.Func{``0[],``1},System.Int32,System.Boolean)">
            <summary>
            Build a IFlux whose data are generated by the combination of the most recent published values from all
            publishers.
            </summary>
            <remarks>
            Marble diagram:
            https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/combinelatest.png
            </remarks>
            <typeparam name="T">The input value type.</typeparam>
            <typeparam name="R">The output value type.</typeparam>
            <param name="combiner">The function that will receive the latest values from all sources and has to produce an output value.</param>
            <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
            unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
            <param name="delayError">If true, errors are delayed until all all source IPublishers have terminated.
            If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
            Exceptions</param>
            <param name="sources">The input IPublisher sources.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Concat``1(System.Collections.Generic.IEnumerable{Reactive.Streams.IPublisher{``0}},System.Boolean)">
            <summary>
            Concatenates an IEnumerable sequence of IPublisher sources, optionally delaying errors until
            all sources have terminated.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="sources">The IEnumerable sequence if IPublisher sources.</param>
            <param name="delayError">If true, errors are delayed until all all source IPublishers have terminated.
            If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
            Exceptions</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Concat``1(System.Boolean,Reactive.Streams.IPublisher{``0}[])">
            <summary>
            Concatenates an parameter array of IPublisher sources.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="delayErrors">If true, errors are delayed until all all source IPublishers have terminated.
            If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
            Exceptions</param>
            <param name="sources">The IEnumerable sequence if IPublisher sources.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Concat``1(Reactive.Streams.IPublisher{Reactive.Streams.IPublisher{``0}},Reactor.Core.ConcatErrorMode)">
            <summary>
            Concatenates a dynamic sequence of IPublisher sources, optionally delaying errors from the outer IPublisher
            and the inner IPublishers until the current IPublisher terminates or all IPublishers terminated.
            </summary>
            <remarks>
            The operator prefetches 2 elements from the outer IPublisher, keeping them ready for subscription
            once the current inner IPublisher terminates.
            </remarks>
            <remarks>
            If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
            Exceptions.
            </remarks>
            <typeparam name="T">The value type.</typeparam>
            <param name="sources">The dynamic sequence of IPublisher sources.</param>
            <param name="errorMode">Specifies the error handling behavior. See <see cref="T:Reactor.Core.ConcatErrorMode"/> constants.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Concat``1(Reactive.Streams.IPublisher{Reactive.Streams.IPublisher{``0}},System.Int32,Reactor.Core.ConcatErrorMode)">
            <summary>
            Concatenates a dynamic sequence of IPublisher sources, optionally delaying errors from the outer IPublisher
            and the inner IPublishers until the current IPublisher terminates or all IPublishers terminated, plus it
            allows specifying how many elements to prefetch from the outer IPublisher.
            </summary>
            <remarks>
            The operator keeps a low-watermark of 25% of the specified prefetch amount.
            </remarks>
            <remarks>
            If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
            Exceptions.
            </remarks>
            <typeparam name="T">The value type.</typeparam>
            <param name="sources">The dynamic sequence of IPublisher sources.</param>
            <param name="prefetch">The number of items to prefetch from the outer IPublisher. If negative, the outer IPublisher is run in
            unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
            <param name="errorMode">Specifies the error handling behavior. See <see cref="T:Reactor.Core.ConcatErrorMode"/> constants.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Create``1(System.Action{Reactor.Core.IFluxEmitter{``0}},Reactor.Core.BackpressureHandling)">
            <summary>
            Creates an IFlux which when subscribed to, calls the specified Action with a IFluxEmitter instance that takes
            care of signalling events and handling backpressure for the downstream.
            </summary>
            <typeparam name="T">The value type signalled.</typeparam>
            <param name="emitter">The action called for each incoming subscriber with an IFluxEmitter instance.</param>
            <param name="backpressure">Specifies how to handle downstream backpressure. See <see cref="T:Reactor.Core.BackpressureHandling"/> for values.</param>
            <returns>The new IFlux isntance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Defer``1(System.Func{Reactive.Streams.IPublisher{``0}})">
            <summary>
            Supply a IPublisher everytime subscribe is called on the returned flux. The passed supplier function
            will be invoked and it's up to the developer to choose to return a new instance of a IPublisher or reuse
            one effecitvely behaving like from(IPublisher).
            </summary>
            <typeparam name="T">The type of values passing through the IFlux.</typeparam>
            <param name="supplier">The IPublisher supplier function to call on subscribe.</param>
            <returns>A deferred IFlux.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Error``1(System.Exception,System.Boolean)">
            <summary>
            Creates an IFlux instance which signals the given exception
            immediately (or when requested).
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="ex">The exception to signal</param>
            <param name="whenRequested">Signal the exception when requested?</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.FirstEmitting``1(Reactive.Streams.IPublisher{``0}[])">
            <summary>
            Relays signals from that source IPublisher that signalled anything first (cancels or doesn't even
            subscribe to the rest).
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="sources">The parameter array of IPublisher sources.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.FirstEmitting``1(System.Collections.Generic.IEnumerable{Reactive.Streams.IPublisher{``0}})">
            <summary>
            Relays signals from that source IPublisher that signalled anything first (cancels or doesn't even
            subscribe to the rest).
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="sources">The IEnumerable sequence of IPublisher sources.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Wrap``1(Reactive.Streams.IPublisher{``0})">
            <summary>
            Wraps the given IPublisher into an IFlux instance if not already an IFlux.
            </summary>
            <typeparam name="T">the source sequence type</typeparam>
            <param name="source">the source to decorate</param>
            <returns>The source or an new IFlux wrapper of it.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.From``1(``0[])">
            <summary>
            Emits the elements of the given parameter array.
            </summary>
            <typeparam name="T">The element type of the array.</typeparam>
            <param name="values">The array of values to emit.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.From``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Emits the elements of the given IEnumerable sequence.
            </summary>
            <typeparam name="T">The element type of the IEnumerable.</typeparam>
            <param name="enumerable">The IEnumerable source of elements to signal.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.From``1(System.IObservable{``0},Reactor.Core.BackpressureHandling)">
            <summary>
            Wraps the specified IObservable into an IFlux and applies the specified backpressure strategy
            (IObservables don't support backpressure on their own).
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IObservable instance.</param>
            <param name="backpressure">The backpressure strategy. See <see cref="T:Reactor.Core.BackpressureHandling"/> enum constants.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.From(System.Threading.Tasks.Task)">
            <summary>
            Creates a valueless IFlux instance from the task which
            signals when the task completes or fails.
            </summary>
            <param name="task">The tast to use as source.</param>
            <returns>The IFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.Flux.From``1(System.Threading.Tasks.Task{``0})">
            <summary>
            Creates a IFlux instance from the task which
            signals a single value when the task completes or 
            signals an Exception if the task fails.
            </summary>
            <param name="task">The tast to use as source.</param>
            <returns>The IFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.Flux.From``1(System.Action)">
            <summary>
            Executes the given action for each subscriber and completes
            or signals an Exception if the action threw.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="action">The action</param>
            <returns>The IMono instance</returns>
        </member>
        <member name="M:Reactor.Core.Flux.From``1(System.Func{``0},System.Boolean)">
            <summary>
            Emits the value returned by the supplier function to each individual subscriber.
            </summary>
            <typeparam name="T">The emitted value type.</typeparam>
            <param name="supplier">The function that is called for each subscriber to return a value to be emitted.</param>
            <param name="nullMeansEmpty">If the supplier returns null, should that be considered as empty source?
            Note that value types don't have a notion of null and their default value is considered a normal value.</param>
            <returns></returns>
        </member>
        <member name="M:Reactor.Core.Flux.Generate``1(System.Action{Reactor.Core.ISignalEmitter{``0}})">
            <summary>
            Generates signals when the downstream requests values in a stateless manner.
            </summary>
            <remarks>
            The generator action is called as many times as the downstream amount.
            For example, a downstream request(2) will call the action twice.
            </remarks>
            <typeparam name="T">The generated value type.</typeparam>
            <param name="generator">The action called with an ISignalEmitter instance for each 
            subscriber and for each downstream request to generate the next value to emit or a 
            teriman signal.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Generate``2(System.Func{``1},System.Func{``1,Reactor.Core.ISignalEmitter{``0},``1})">
            <summary>
            Generates signals when the downstream requests values in a stateful manner.
            </summary>
            <remarks>
            The generator action is called as many times as the downstream amount.
            For example, a downstream request(2) will call the action twice.
            </remarks>
            <typeparam name="T">The generated value type.</typeparam>
            <typeparam name="S">The state type.</typeparam>
            <param name="stateSupplier">The function returning the initial state object or structure for each subscriber.</param>
            <param name="generator">The action called with the current state value and a ISignalEmitter instance for each 
            subscriber and for each downstream request to generate the next value to emit or a 
            teriman signal. The function's return value should be the new state (which is used the next time this function is called).</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Generate``2(System.Func{``1},System.Func{``1,Reactor.Core.ISignalEmitter{``0},``1},System.Action{``1})">
            <summary>
            Generates signals when the downstream requests values in a stateful manner.
            </summary>
            <remarks>
            The generator action is called as many times as the downstream amount.
            For example, a downstream request(2) will call the action twice.
            </remarks>
            <typeparam name="T">The generated value type.</typeparam>
            <typeparam name="S">The state type.</typeparam>
            <param name="stateSupplier">The function returning the initial state object or structure for each subscriber.</param>
            <param name="generator">The action called with the current state value and a ISignalEmitter instance for each 
            subscriber and for each downstream request to generate the next value to emit or a 
            teriman signal. The function's return value should be the new state (which is used the next time this function is called).</param>
            <param name="stateDisposer">The action to call to dispose the state generated/modified by the other functions. This function
            is called exactly once for each subscriber whenever the generator signals a terminal event or the sequence gets cancelled.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Interval(System.TimeSpan)">
            <summary>
            Generates a sequence of long numbers, starting from 0, with the given periodicity, running
            on the default timed scheduler.
            </summary>
            <param name="period">The period at which numbers are signalled.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Interval(System.TimeSpan,Reactor.Core.TimedScheduler)">
            <summary>
            Generates a sequence of long numbers, starting from 0, with the given periodicity, running
            on the specified timed scheduler.
            </summary>
            <param name="period">The period at which numbers are signalled.</param>
            <param name="scheduler">The scheduler to use for emitting each number.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Interval(System.TimeSpan,System.TimeSpan)">
            <summary>
            Generates a sequence of long numbers, starting from 0, with the given periodicity and after the
            initial delay, running on the default timed scheduler.
            </summary>
            <param name="initialDelay">The initial delay before signalling 0.</param>
            <param name="period">The period at which subsequent numbers are signalled.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Interval(System.TimeSpan,System.TimeSpan,Reactor.Core.TimedScheduler)">
            <summary>
            Generates a sequence of long numbers, starting from 0, with the given periodicity and after the
            initial delay, running on the default timed scheduler.
            </summary>
            <param name="initialDelay">The initial delay before signalling 0.</param>
            <param name="period">The period at which numbers are signalled.</param>
            <param name="scheduler">The scheduler to use for emitting each number.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Merge``1(System.Boolean,Reactive.Streams.IPublisher{``0}[])">
            <summary>
            Merges the values from the specified parameter array of source IPublishers, optionally delaying
            any of their errors until all sources terminate.
            </summary>
            <remarks>
            The operator merges at most <see cref="P:Reactor.Core.Flux.BufferSize"/> number of sources at once and uses
            <see cref="P:Reactor.Core.Flux.BufferSize"/> prefetch for those sources.
            </remarks>
            <typeparam name="T">The value type.</typeparam>
            <param name="delayErrors">If true, errors are delayed until all all source IPublishers have terminated.
            If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
            Exceptions</param>
            <param name="sources">The parameter array of IPublisher sources to merge.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Merge``1(System.Int32,System.Boolean,Reactive.Streams.IPublisher{``0}[])">
            <summary>
            Merges the values from the specified parameter array of source IPublishers, at most
            <paramref name="maxConcurrency"/> sources at once, optionally delaying any of their errors until
            all sources terminate.
            </summary>
            <remarks>
            The operator uses <see cref="P:Reactor.Core.Flux.BufferSize"/> prefetch for those sources.
            </remarks>
            <typeparam name="T">The value type.</typeparam>
            <param name="maxConcurrency">The maximum number of sources to merge at once.</param>
            <param name="delayErrors">If true, errors are delayed until all all source IPublishers have terminated.
            If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
            Exceptions</param>
            <param name="sources">The parameter array of IPublisher sources to merge.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Merge``1(System.Int32,System.Int32,System.Boolean,Reactive.Streams.IPublisher{``0}[])">
            <summary>
            Merges the values from the specified parameter array of source IPublishers, at most
            <paramref name="maxConcurrency"/> sources at once, using the specified prefetch for these sources,
            optionally delaying any of their errors until all sources terminate.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="maxConcurrency">The maximum number of sources to merge at once.</param>
            <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
            unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
            <param name="delayErrors">If true, errors are delayed until all all source IPublishers have terminated.
            If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
            Exceptions</param>
            <param name="sources">The parameter array of IPublisher sources to merge.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Merge``1(System.Collections.Generic.IEnumerable{Reactive.Streams.IPublisher{``0}},System.Boolean)">
            <summary>
            Merges the values from the specified IEnumerable sequence of source IPublishers, optionally delaying
            any of their errors until all sources terminate.
            </summary>
            <remarks>
            The operator merges at most <see cref="P:Reactor.Core.Flux.BufferSize"/> number of sources at once and uses
            <see cref="P:Reactor.Core.Flux.BufferSize"/> prefetch for those sources.
            </remarks>
            <typeparam name="T">The value type.</typeparam>
            <param name="delayErrors">If true, errors are delayed until all all source IPublishers have terminated.
            If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
            Exceptions</param>
            <param name="sources">The IEnumerable sequence of IPublisher sources to merge.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Merge``1(System.Collections.Generic.IEnumerable{Reactive.Streams.IPublisher{``0}},System.Int32,System.Boolean)">
            <summary>
            Merges the values from the specified IEnumerable sequence of source IPublishers, at most
            <paramref name="maxConcurrency"/> sources at once, optionally delaying any of their errors until
            all sources terminate.
            </summary>
            <remarks>
            The operator uses <see cref="P:Reactor.Core.Flux.BufferSize"/> prefetch for those sources.
            </remarks>
            <typeparam name="T">The value type.</typeparam>
            <param name="maxConcurrency">The maximum number of sources to merge at once.</param>
            <param name="delayErrors">If true, errors are delayed until all all source IPublishers have terminated.
            If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
            Exceptions</param>
            <param name="sources">The IEnumerable sequence of IPublisher sources to merge.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Merge``1(System.Collections.Generic.IEnumerable{Reactive.Streams.IPublisher{``0}},System.Int32,System.Int32,System.Boolean)">
            <summary>
            Merges the values from the specified IEnumerable sequence of source IPublishers, at most
            <paramref name="maxConcurrency"/> sources at once, using the specified prefetch for these sources,
            optionally delaying any of their errors until all sources terminate.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="maxConcurrency">The maximum number of sources to merge at once.</param>
            <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
            unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
            <param name="delayErrors">If true, errors are delayed until all all source IPublishers have terminated.
            If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
            Exceptions</param>
            <param name="sources">The IEnumerable sequence of IPublisher sources to merge.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Merge``1(Reactive.Streams.IPublisher{Reactive.Streams.IPublisher{``0}},System.Boolean)">
            <summary>
            Merges the values from the specified dynamic outer IPublisher sequence of inner source IPublishers, optionally delaying
            any of their errors until all sources terminate.
            </summary>
            <remarks>
            The operator merges at most <see cref="P:Reactor.Core.Flux.BufferSize"/> number of sources at once and uses
            <see cref="P:Reactor.Core.Flux.BufferSize"/> prefetch for those sources.
            </remarks>
            <typeparam name="T">The value type.</typeparam>
            <param name="delayErrors">If true, errors are delayed until all all source IPublishers have terminated.
            If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
            Exceptions</param>
            <param name="sources">The dynamic outer IPublisher of inner IPublisher sources to merge.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Merge``1(Reactive.Streams.IPublisher{Reactive.Streams.IPublisher{``0}},System.Int32,System.Boolean)">
            <summary>
            Merges the values from the specified dynamic outer IPublisher sequence of inner source IPublishers, at most
            <paramref name="maxConcurrency"/> sources at once, optionally delaying any of their errors until
            all sources terminate.
            </summary>
            <remarks>
            The operator uses <see cref="P:Reactor.Core.Flux.BufferSize"/> prefetch for those sources.
            </remarks>
            <typeparam name="T">The value type.</typeparam>
            <param name="maxConcurrency">The maximum number of inner sources to merge at once.</param>
            <param name="delayErrors">If true, errors are delayed until all all source IPublishers have terminated.
            If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
            Exceptions</param>
            <param name="sources">The dynamic outer IPublisher of inner IPublisher sources to merge.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Merge``1(Reactive.Streams.IPublisher{Reactive.Streams.IPublisher{``0}},System.Int32,System.Int32,System.Boolean)">
            <summary>
            Merges the values from the specified dynamic outer IPublisher sequence of inner IPublishers, at most
            <paramref name="maxConcurrency"/> sources at once, using the specified prefetch for these sources,
            optionally delaying any of their errors until all sources terminate.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="maxConcurrency">The maximum number of inner sources to merge at once.</param>
            <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
            unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
            <param name="delayErrors">If true, errors are delayed until all all source IPublishers have terminated.
            If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
            Exceptions</param>
            <param name="sources">The dynamic outer IPublisher of inner IPublisher sources to merge.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Range(System.Int32,System.Int32)">
            <summary>
            Signals a range of values from start to start + count (exclusive).
            </summary>
            <param name="start">The start value</param>
            <param name="count">The number of items, non-negative</param>
            <returns></returns>
        </member>
        <member name="M:Reactor.Core.Flux.SwitchOnNext``1(Reactive.Streams.IPublisher{Reactive.Streams.IPublisher{``0}})">
            <summary>
            Relays signals of the inner IPublisher sources until the outer IPublisher produces another inner source.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="sources">The dynamic IPublisher sequence of inner IPublisher sources.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.SwitchOnNext``1(Reactive.Streams.IPublisher{Reactive.Streams.IPublisher{``0}},System.Int32)">
            <summary>
            Relays signals of the inner IPublisher sources until the outer IPublisher produces another inner source.
            It uses the given prefetch amount on the inner IPublisher sources.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="sources">The dynamic IPublisher sequence of inner IPublisher sources.</param>
            <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
            unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
            <returns></returns>
        </member>
        <member name="M:Reactor.Core.Flux.Timer(System.TimeSpan)">
            <summary>
            Signals a single long 0 after the specified delay on the default timed scheduler.
            </summary>
            <param name="delay">The delay amount.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Timer(System.TimeSpan,Reactor.Core.TimedScheduler)">
            <summary>
            Signals a single long 0 after the specified delay on the specified timed scheduler.
            </summary>
            <param name="delay">The delay amount.</param>
            <param name="scheduler">The target timed scheduler.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Using``2(System.Func{``1},System.Func{``1,Reactive.Streams.IPublisher{``0}},System.Action{``1},System.Boolean)">
            <summary>
            Uses a generated resource, derives an IPublisher from it whose signals are relayed and
            disposes the generated resource once the IPublisher terminates or gets cancelled.
            </summary>
            <typeparam name="T">The value type signalled.</typeparam>
            <typeparam name="S">The resource type.</typeparam>
            <param name="resourceSupplier">Function that returns a resource for each subscriber</param>
            <param name="publisherFactory">Function that receives the generated resource and returns an IPublisher to be relayed for each subscriber.</param>
            <param name="resourceDisposer">The action called to dispose the generated resource.</param>
            <param name="eager">If true, the resourceDisposer is called before signalling the terminal event; after otherwise.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Zip``2(System.Func{``0[],``1},System.Boolean,Reactive.Streams.IPublisher{``0}[])">
            <summary>
            Combines a row of values, the next from each IPublisher source, through a function and emits the resulting value.
            </summary>
            <typeparam name="T">The input value type.</typeparam>
            <typeparam name="R">The output value type.</typeparam>
            <param name="zipper">The function that receives an array of values, as many as there are sources and returns
            a value to be emitted.</param>
            <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
            signalling an AggregateException if there were more than one Exception.</param>
            <param name="sources">The parameter array of IPublisher sources to combine.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Zip``2(System.Func{``0[],``1},System.Int32,System.Boolean,Reactive.Streams.IPublisher{``0}[])">
            <summary>
            Combines a row of values, the next from each IPublisher source, through a function and emits the resulting value
            while prefetching the given amount from each of these IPublisher sources.
            </summary>
            <typeparam name="T">The input value type.</typeparam>
            <typeparam name="R">The output value type.</typeparam>
            <param name="zipper">The function that receives an array of values, as many as there are sources and returns
            a value to be emitted.</param>
            <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
            unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
            <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
            signalling an AggregateException if there were more than one Exception.</param>
            <param name="sources">The parameter array of IPublisher sources to combine.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Zip``2(System.Collections.Generic.IEnumerable{Reactive.Streams.IPublisher{``0}},System.Func{``0[],``1},System.Boolean)">
            <summary>
            Combines a row of values, the next from each IPublisher source from the IEnumerable sequence,
            through a function and emits the resulting value.
            </summary>
            <typeparam name="T">The input value type.</typeparam>
            <typeparam name="R">The output value type.</typeparam>
            <param name="zipper">The function that receives an array of values, as many as there are sources and returns
            a value to be emitted.</param>
            <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
            signalling an AggregateException if there were more than one Exception.</param>
            <param name="sources">The IEnumerable sequence of IPublisher sources to combine.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Zip``2(System.Collections.Generic.IEnumerable{Reactive.Streams.IPublisher{``0}},System.Func{``0[],``1},System.Int32,System.Boolean)">
            <summary>
            Combines a row of values, the next from each IPublisher source from the IEnumerable sequence,
            through a function and emits the resulting value
            while prefetching the given amount from each of these IPublisher sources.
            </summary>
            <typeparam name="T">The input value type.</typeparam>
            <typeparam name="R">The output value type.</typeparam>
            <param name="zipper">The function that receives an array of values, as many as there are sources and returns
            a value to be emitted.</param>
            <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
            unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
            <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
            signalling an AggregateException if there were more than one Exception.</param>
            <param name="sources">The IEnumerable sequence of IPublisher sources to combine.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Zip``3(Reactive.Streams.IPublisher{``0},Reactive.Streams.IPublisher{``1},System.Func{``0,``1,``2},System.Boolean)">
            <summary>
            Combines a row of values, the next from each IPublisher source,
            through a function and emits the resulting value.
            </summary>
            <typeparam name="T1">The first input value type.</typeparam>
            <typeparam name="T2">The second input value type.</typeparam>
            <typeparam name="R">The output value type.</typeparam>
            <param name="p1">The first source IPublisher.</param>
            <param name="p2">The second source IPublisher.</param>
            <param name="zipper">The function that receives an array of values, as many as there are sources and returns
            a value to be emitted.</param>
            <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
            signalling an AggregateException if there were more than one Exception.</param>
        </member>
        <member name="M:Reactor.Core.Flux.Zip``3(Reactive.Streams.IPublisher{``0},Reactive.Streams.IPublisher{``1},System.Func{``0,``1,``2},System.Int32,System.Boolean)">
            <summary>
            Combines a row of values, the next from each IPublisher source,
            through a function and emits the resulting value.
            </summary>
            <typeparam name="T1">The first input value type.</typeparam>
            <typeparam name="T2">The second input value type.</typeparam>
            <typeparam name="R">The output value type.</typeparam>
            <param name="p1">The first source IPublisher.</param>
            <param name="p2">The second source IPublisher.</param>
            <param name="zipper">The function that receives an array of values, as many as there are sources and returns
            a value to be emitted.</param>
            <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
            unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
            <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
            signalling an AggregateException if there were more than one Exception.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Zip``4(Reactive.Streams.IPublisher{``0},Reactive.Streams.IPublisher{``1},Reactive.Streams.IPublisher{``1},System.Func{``0,``1,``2,``3},System.Boolean)">
            <summary>
            Combines a row of values, the next from each IPublisher source,
            through a function and emits the resulting value.
            </summary>
            <typeparam name="T1">The first input value type.</typeparam>
            <typeparam name="T2">The second input value type.</typeparam>
            <typeparam name="T3">The third input value type.</typeparam>
            <typeparam name="R">The output value type.</typeparam>
            <param name="p1">The first source IPublisher.</param>
            <param name="p2">The second source IPublisher.</param>
            <param name="p3">The third source IPublisher.</param>
            <param name="zipper">The function that receives an array of values, as many as there are sources and returns
            a value to be emitted.</param>
            <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
            signalling an AggregateException if there were more than one Exception.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Zip``4(Reactive.Streams.IPublisher{``0},Reactive.Streams.IPublisher{``1},Reactive.Streams.IPublisher{``1},System.Func{``0,``1,``2,``3},System.Int32,System.Boolean)">
            <summary>
            Combines a row of values, the next from each IPublisher source,
            through a function and emits the resulting value.
            </summary>
            <typeparam name="T1">The first input value type.</typeparam>
            <typeparam name="T2">The second input value type.</typeparam>
            <typeparam name="T3">The third input value type.</typeparam>
            <typeparam name="R">The output value type.</typeparam>
            <param name="p1">The first source IPublisher.</param>
            <param name="p2">The second source IPublisher.</param>
            <param name="p3">The third source IPublisher.</param>
            <param name="zipper">The function that receives an array of values, as many as there are sources and returns
            a value to be emitted.</param>
            <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
            unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
            <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
            signalling an AggregateException if there were more than one Exception.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Zip``5(Reactive.Streams.IPublisher{``0},Reactive.Streams.IPublisher{``1},Reactive.Streams.IPublisher{``1},Reactive.Streams.IPublisher{``3},System.Func{``0,``1,``2,``3,``4},System.Boolean)">
            <summary>
            Combines a row of values, the next from each IPublisher source,
            through a function and emits the resulting value.
            </summary>
            <typeparam name="T1">The first input value type.</typeparam>
            <typeparam name="T2">The second input value type.</typeparam>
            <typeparam name="T3">The third input value type.</typeparam>
            <typeparam name="T4">The fourth input value type.</typeparam>
            <typeparam name="R">The output value type.</typeparam>
            <param name="p1">The first source IPublisher.</param>
            <param name="p2">The second source IPublisher.</param>
            <param name="p3">The third source IPublisher.</param>
            <param name="p4">The fourth source IPublisher.</param>
            <param name="zipper">The function that receives an array of values, as many as there are sources and returns
            a value to be emitted.</param>
            <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
            signalling an AggregateException if there were more than one Exception.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Zip``5(Reactive.Streams.IPublisher{``0},Reactive.Streams.IPublisher{``1},Reactive.Streams.IPublisher{``1},Reactive.Streams.IPublisher{``3},System.Func{``0,``1,``2,``3,``4},System.Int32,System.Boolean)">
            <summary>
            Combines a row of values, the next from each IPublisher source,
            through a function and emits the resulting value.
            </summary>
            <typeparam name="T1">The first input value type.</typeparam>
            <typeparam name="T2">The second input value type.</typeparam>
            <typeparam name="T3">The third input value type.</typeparam>
            <typeparam name="T4">The fourth input value type.</typeparam>
            <typeparam name="R">The output value type.</typeparam>
            <param name="p1">The first source IPublisher.</param>
            <param name="p2">The second source IPublisher.</param>
            <param name="p3">The third source IPublisher.</param>
            <param name="p4">The fourth source IPublisher.</param>
            <param name="zipper">The function that receives an array of values, as many as there are sources and returns
            a value to be emitted.</param>
            <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
            unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
            <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
            signalling an AggregateException if there were more than one Exception.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Zip``6(Reactive.Streams.IPublisher{``0},Reactive.Streams.IPublisher{``1},Reactive.Streams.IPublisher{``1},Reactive.Streams.IPublisher{``3},Reactive.Streams.IPublisher{``4},System.Func{``0,``1,``2,``3,``4,``5},System.Boolean)">
            <summary>
            Combines a row of values, the next from each IPublisher source,
            through a function and emits the resulting value.
            </summary>
            <typeparam name="T1">The first input value type.</typeparam>
            <typeparam name="T2">The second input value type.</typeparam>
            <typeparam name="T3">The third input value type.</typeparam>
            <typeparam name="T4">The fourth input value type.</typeparam>
            <typeparam name="T5">The fifth input value type.</typeparam>
            <typeparam name="R">The output value type.</typeparam>
            <param name="p1">The first source IPublisher.</param>
            <param name="p2">The second source IPublisher.</param>
            <param name="p3">The third source IPublisher.</param>
            <param name="p4">The fourth source IPublisher.</param>
            <param name="p5">The fifth source IPublisher.</param>
            <param name="zipper">The function that receives an array of values, as many as there are sources and returns
            a value to be emitted.</param>
            <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
            signalling an AggregateException if there were more than one Exception.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Zip``6(Reactive.Streams.IPublisher{``0},Reactive.Streams.IPublisher{``1},Reactive.Streams.IPublisher{``1},Reactive.Streams.IPublisher{``3},Reactive.Streams.IPublisher{``4},System.Func{``0,``1,``2,``3,``4,``5},System.Int32,System.Boolean)">
            <summary>
            Combines a row of values, the next from each IPublisher source,
            through a function and emits the resulting value.
            </summary>
            <typeparam name="T1">The first input value type.</typeparam>
            <typeparam name="T2">The second input value type.</typeparam>
            <typeparam name="T3">The third input value type.</typeparam>
            <typeparam name="T4">The fourth input value type.</typeparam>
            <typeparam name="T5">The fifth input value type.</typeparam>
            <typeparam name="R">The output value type.</typeparam>
            <param name="p1">The first source IPublisher.</param>
            <param name="p2">The second source IPublisher.</param>
            <param name="p3">The third source IPublisher.</param>
            <param name="p4">The fourth source IPublisher.</param>
            <param name="p5">The fifth source IPublisher.</param>
            <param name="zipper">The function that receives an array of values, as many as there are sources and returns
            a value to be emitted.</param>
            <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
            unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
            <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
            signalling an AggregateException if there were more than one Exception.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Zip``7(Reactive.Streams.IPublisher{``0},Reactive.Streams.IPublisher{``1},Reactive.Streams.IPublisher{``1},Reactive.Streams.IPublisher{``3},Reactive.Streams.IPublisher{``4},Reactive.Streams.IPublisher{``5},System.Func{``0,``1,``2,``3,``4,``5,``6},System.Boolean)">
            <summary>
            Combines a row of values, the next from each IPublisher source,
            through a function and emits the resulting value.
            </summary>
            <typeparam name="T1">The first input value type.</typeparam>
            <typeparam name="T2">The second input value type.</typeparam>
            <typeparam name="T3">The third input value type.</typeparam>
            <typeparam name="T4">The fourth input value type.</typeparam>
            <typeparam name="T5">The fifth input value type.</typeparam>
            <typeparam name="T6">The sixth input value type.</typeparam>
            <typeparam name="R">The output value type.</typeparam>
            <param name="p1">The first source IPublisher.</param>
            <param name="p2">The second source IPublisher.</param>
            <param name="p3">The third source IPublisher.</param>
            <param name="p4">The fourth source IPublisher.</param>
            <param name="p5">The fifth source IPublisher.</param>
            <param name="p6">The sixth source IPublisher.</param>
            <param name="zipper">The function that receives an array of values, as many as there are sources and returns
            a value to be emitted.</param>
            <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
            signalling an AggregateException if there were more than one Exception.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Zip``7(Reactive.Streams.IPublisher{``0},Reactive.Streams.IPublisher{``1},Reactive.Streams.IPublisher{``1},Reactive.Streams.IPublisher{``3},Reactive.Streams.IPublisher{``4},Reactive.Streams.IPublisher{``5},System.Func{``0,``1,``2,``3,``4,``5,``6},System.Int32,System.Boolean)">
            <summary>
            Combines a row of values, the next from each IPublisher source,
            through a function and emits the resulting value.
            </summary>
            <typeparam name="T1">The first input value type.</typeparam>
            <typeparam name="T2">The second input value type.</typeparam>
            <typeparam name="T3">The third input value type.</typeparam>
            <typeparam name="T4">The fourth input value type.</typeparam>
            <typeparam name="T5">The fifth input value type.</typeparam>
            <typeparam name="T6">The sixth input value type.</typeparam>
            <typeparam name="R">The output value type.</typeparam>
            <param name="p1">The first source IPublisher.</param>
            <param name="p2">The second source IPublisher.</param>
            <param name="p3">The third source IPublisher.</param>
            <param name="p4">The fourth source IPublisher.</param>
            <param name="p5">The fifth source IPublisher.</param>
            <param name="p6">The sixth source IPublisher.</param>
            <param name="zipper">The function that receives an array of values, as many as there are sources and returns
            a value to be emitted.</param>
            <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
            unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
            <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
            signalling an AggregateException if there were more than one Exception.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Map``2(Reactor.Core.IFlux{``0},System.Func{``0,``1})">
            <summary>
            Transform the items emitted by this IFlux by applying a function to each item.
            </summary>
            <typeparam name="T">The input value type</typeparam>
            <typeparam name="R">The output value type</typeparam>
            <param name="source">The source IFlux</param>
            <param name="mapper">The mapper from Ts to Rs</param>
            <returns>The new IFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.Flux.As``2(Reactor.Core.IFlux{``0},System.Func{Reactor.Core.IFlux{``0},``1})">
            <summary>
            Apply the transformer function on the source IFlux; this allows fluent conversion
            to any other type.
            </summary>
            <typeparam name="T">The input IFlux value type.</typeparam>
            <typeparam name="R">The output type.</typeparam>
            <param name="source">The source IFlux to transform.</param>
            <param name="transformer">The transformer, receiving the IFlux source and returns a value.</param>
            <returns>The value returned by the transformer function.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Any``1(Reactor.Core.IFlux{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns an IMono containing true if the source contains any item the predicate
            matches.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="predicate">The predicate to apply to each item in the sequence.</param>
            <returns>The new IMono containing either true or false.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.All``1(Reactor.Core.IFlux{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns an IMono containing true if all items from the source match the predicate.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="predicate">The predicate to be mached by all source elements.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Buffer``1(Reactor.Core.IFlux{``0})">
            <summary>
            Buffers all elements from the source sequence into an IList.
            This operator requires a finite source.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <returns>The new IFlux instance holding the IList of all source values.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Buffer``1(Reactor.Core.IFlux{``0},System.Int32)">
            <summary>
            Buffers elements into non-overlapping sub-buffers with the specified number of elements in
            each.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="size">The size of each IList buffer (except the last once which could be smaller).</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Buffer``1(Reactor.Core.IFlux{``0},System.Int32,System.Int32)">
            <summary>
            Buffers elements into potentially overlapping sub-buffers with the specified number of elements in
            each and sub-buffers started after the skip amount.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="size">The number of elements to store in each sub-buffer.</param>
            <param name="skip">The number of elements to let pass to start the next buffer.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Buffer``2(Reactor.Core.IFlux{``0},Reactive.Streams.IPublisher{``1})">
            <summary>
            Buffers elements into non-overlapping sub-buffers whose boundary is established by
            an OnNext signal from the boundary IPublisher.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="U">The boundary value type.</typeparam>
            <param name="source">The source IFlux of values to buffer.</param>
            <param name="boundary">The boundary IPublisher signalling the end and start of each sub-buffer.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Buffer``3(Reactor.Core.IFlux{``0},Reactive.Streams.IPublisher{``1},System.Func{``1,Reactive.Streams.IPublisher{``2}})">
            <summary>
            Buffers elements into potentially overlapping sub-buffers which are opened by an IPublisher
            and closed by another, derived IPublisher signalling.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="U">The buffer-opening sequence type.</typeparam>
            <typeparam name="V">The buffer-closing sequence type.</typeparam>
            <param name="source">The source IFlux</param>
            <param name="open">The IPublisher opening buffers</param>
            <param name="close">The function generating an IPublisher to close a buffer opened 
            by the value from <paramref name="open"/> sequence.</param>
            <returns>The nex IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Buffer``1(Reactor.Core.IFlux{``0},System.TimeSpan)">
            <summary>
            Buffers elements into non-overlapping sub-buffers for the specified timespan duration each.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="timespan">The time duration for each sub-buffer.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Buffer``1(Reactor.Core.IFlux{``0},System.TimeSpan,Reactor.Core.TimedScheduler)">
            <summary>
            Buffers elements into non-overlapping sub-buffers for the specified timespan duration each,
            determined by the given timed scheduler.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="timespan">The time duration for each sub-buffer.</param>
            <param name="scheduler">The timed scheduler to give the notion of time for the sub-buffer duration</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Buffer``1(Reactor.Core.IFlux{``0},System.TimeSpan,System.TimeSpan)">
            <summary>
            Buffers elements into potentially overlapping sub-buffers, buffering for the specified timespan each
            and starting new buffers after the specified timeskip time.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="timespan">The duration for each sub-buffer.</param>
            <param name="timeskip">The time to skip before starting a new sub-buffer.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Buffer``1(Reactor.Core.IFlux{``0},System.TimeSpan,System.TimeSpan,Reactor.Core.TimedScheduler)">
            <summary>
            Buffers elements into potentially overlapping sub-buffers, buffering for the specified timespan each
            and starting new buffers after the specified timeskip time, as determined by the given timed scheduler.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="timespan">The duration for each sub-buffer.</param>
            <param name="timeskip">The time to skip before starting a new sub-buffer.</param>
            <param name="scheduler">The timed scheduler to provide the timing of sub-buffer boundaries.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Buffer``1(Reactor.Core.IFlux{``0},System.Int32,System.TimeSpan)">
            <summary>
            Buffer elements into non-overlapping sub-buffers limited by a maximum size or buffering duration.
            If the maximum size is reached, the time duration is restarted from that point.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="maxSize">The maximum number of elements in each sub-buffer.</param>
            <param name="timespan">The duration of buffering into each sub-buffer.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Buffer``1(Reactor.Core.IFlux{``0},System.Int32,System.TimeSpan,Reactor.Core.TimedScheduler)">
            <summary>
            Buffer elements into non-overlapping sub-buffers limited by a maximum size or buffering duration.
            If the maximum size is reached, the time duration is restarted from that point,
            where timing is determined by the given timed scheduler.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="maxSize">The maximum number of elements in each sub-buffer.</param>
            <param name="timespan">The duration of buffering into each sub-buffer.</param>
            <param name="scheduler">The timed scheduler to provide the timing of sub-buffer boundaries.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Cache``1(Reactor.Core.IFlux{``0},System.Int32)">
            <summary>
            Caches all (or the last <paramref name="history"/>) elements from the source IFlux and
            replays them to every subscriber. The caching starts when the first subscriber subscribes.
            </summary>
            <remarks>
            The cache can't be cleared or restarted. See <see cref="M:Reactor.Core.Flux.Replay``1(Reactor.Core.IFlux{``0})"/>.
            </remarks>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source sequence.</param>
            <param name="history">The number of elements to retain.</param>
            <returns>The IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Cast``2(Reactor.Core.IFlux{``0})">
            <summary>
            Casts elements of the source sequence into the given type or
            signals InvalidCastException if any of the source elements can't
            be cast to that target type.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="R">The target value type.</typeparam>
            <param name="source">The source sequence.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Collect``2(Reactor.Core.IFlux{``0},System.Func{``1},System.Action{``1,``0})">
            <summary>
            Collects values into a custom collection, provided by a factory for each subscriber,
            via a collector action and emits this collection at the end.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="C">The collection type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="collectionSupplier">The supplier of the collection.</param>
            <param name="collector">The action called with the collection and the current source value.</param>
            <returns>The new IMono instance with the collection.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.CollectList``1(Reactor.Core.IFlux{``0},System.Int32)">
            <summary>
            Collects all source values into an IList and returns it as an IMono.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="capacityHint">The expected number of elements. (Reduce number of times the list has to be resized).</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.CollectSortedList``1(Reactor.Core.IFlux{``0},System.Collections.Generic.IComparer{``0},System.Int32)">
            <summary>
            Collects all source values into an sorted IList and returns it as an IMono.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="comparer">The comparer function to compare elements.</param>
            <param name="capacityHint">The expected number of elements. (Reduce number of times the list has to be resized).</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.CollectDictionary``2(Reactor.Core.IFlux{``0},System.Func{``0,``1})">
            <summary>
            Collects all values into a Dictionary where the keys are derived via function.
            </summary>
            <remarks>
            Source values mapping to the same key are overwritten.
            </remarks>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="K">The key type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="keySelector">The function that extracts the key from the source values.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.CollectDictionary``3(Reactor.Core.IFlux{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <summary>
            Collects all values into a Dictionary where the keys and values are derived via functions.
            </summary>
            <remarks>
            Source values mapping to the same key are overwritten.
            </remarks>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="K">The key type.</typeparam>
            <typeparam name="V">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="keySelector">The function that extracts the key from the source element.</param>
            <param name="valueSelector">The function that extracts the value from the source element</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.CollectMultiDictionary``2(Reactor.Core.IFlux{``0},System.Func{``0,``1})">
            <summary>
            Collects elements mapping to the same key through a function into a list in a dictionary.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="K">The key type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="keySelector">The function that extracts the key from the source element.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.CollectMultiDictionary``3(Reactor.Core.IFlux{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <summary>
            Collects elements, transformed by a function, mapping to the same key through a function into a list in a dictionary.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="K">The key type.</typeparam>
            <typeparam name="V">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="keySelector">The function that extracts the key from the source element.</param>
            <param name="valueSelector">The function that extracts the value from each source element.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Compose``2(Reactor.Core.IFlux{``0},System.Func{Reactor.Core.IFlux{``0},Reactive.Streams.IPublisher{``1}})">
            <summary>
            Transforms the source IFlux into an IPublisher at subscription time (for each subscriber), allowing
            custom behavior to be injected into a flow.
            </summary>
            <remarks>
            Because the function is called at subscription time, the composition can have sequence-local
            state associated. 
            <p/>
            To do an assembly time composition, use the <see cref="M:Reactor.Core.Flux.As``2(Reactor.Core.IFlux{``0},System.Func{Reactor.Core.IFlux{``0},``1})"/>
            operator with a IPublisher-returning function.
            </remarks>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="R">The output value type</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="composer">The function called for each subscriber, receiving the source and returning
            an IPublisher that will be subscribed to.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.ConcatMap``2(Reactor.Core.IFlux{``0},System.Func{``0,Reactive.Streams.IPublisher{``1}},Reactor.Core.ConcatErrorMode)">
            <summary>
            Concatenates IPublishers generated by a mapper function from the values of the source IPublisher.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="R">The result value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="mapper">The function that maps each source value into an IPublisher.</param>
            <param name="errorMode">Specifies the error handling behavior. See <see cref="T:Reactor.Core.ConcatErrorMode"/> constants.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.ConcatMap``2(Reactor.Core.IFlux{``0},System.Func{``0,Reactive.Streams.IPublisher{``1}},System.Int32,Reactor.Core.ConcatErrorMode)">
            <summary>
            Concatenates IPublishers generated by a mapper function from the values of the source IPublisher.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="R">The result value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="mapper">The function that maps each source value into an IPublisher.</param>
            <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
            unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
            <param name="errorMode">Specifies the error handling behavior. See <see cref="T:Reactor.Core.ConcatErrorMode"/> constants.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.ConcatMap``2(Reactor.Core.IFlux{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},Reactor.Core.ConcatErrorMode)">
            <summary>
            Concatenates IEnumerable sequences generated by a mapper function from the values of the source IPublisher.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="R">The result value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="mapper">The function that maps each source value into an IEnumerable.</param>
            <param name="errorMode">Specifies the error handling behavior. See <see cref="T:Reactor.Core.ConcatErrorMode"/> constants.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.ConcatMap``2(Reactor.Core.IFlux{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Int32,Reactor.Core.ConcatErrorMode)">
            <summary>
            Concatenates IEnumerable sequences generated by a mapper function from the values of the source IPublisher.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="R">The result value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="mapper">The function that maps each source value into an IEnumerable.</param>
            <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
            unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
            <param name="errorMode">Specifies the error handling behavior. See <see cref="T:Reactor.Core.ConcatErrorMode"/> constants.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.ConcatWith``1(Reactor.Core.IFlux{``0},Reactor.Core.IFlux{``0},System.Boolean)">
            <summary>
            Concatenates the source IFlux sequence with the other IPublisher sequence, optionally delaying an OnError signal
            from the first one until the other sequence terminates.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="other">The other IPublisher sequence</param>
            <param name="delayError">If true, OnError signals are delayed until the other IPublisher sequence terminates.
            If both signal an OnError, the sequence signals an AggregateException of the two Exceptions.</param>
            <returns></returns>
        </member>
        <member name="M:Reactor.Core.Flux.Count``1(Reactor.Core.IFlux{``0})">
            <summary>
            Counts the number if elements in the IFlux sequence.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.DefaultIfEmpty``1(Reactor.Core.IFlux{``0},``0)">
            <summary>
            Signals a default value if the source IFlux sequence is empty.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="defaultValue">The default value to signal.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Delay``1(Reactor.Core.IFlux{``0},System.TimeSpan)">
            <summary>
            Shifts the emission of the source IPublisher signals in time by the given amount,
            determined by the default timed scheduler.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="delay">The shift amount.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Delay``1(Reactor.Core.IFlux{``0},System.TimeSpan,Reactor.Core.TimedScheduler)">
            <summary>
            Shifts the emission of the source IPublisher signals in time by the given amount,
            determined by the given timed scheduler.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="delay">The shift amount.</param>
            <param name="scheduler">The timed scheduler to use for the time shifting.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.DelaySubscription``1(Reactor.Core.IFlux{``0},System.TimeSpan)">
            <summary>
            Delays the actual subscription to the source IFlux instance until the specified delay
            has elapsed, as determined by the default timed scheduler.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="delay">The delay amount</param>
            <returns>The new IFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.Flux.DelaySubscription``1(Reactor.Core.IFlux{``0},System.TimeSpan,Reactor.Core.TimedScheduler)">
            <summary>
            Delays the actual subscription to the source IFlux instance until the specified delay
            has elapsed, as determined by the given timed scheduler.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="delay">The delay amount</param>
            <param name="scheduler">The timed scheduler to use for the time shifting.</param>
            <returns>The new IFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.Flux.DelaySubscription``2(Reactor.Core.IFlux{``0},Reactive.Streams.IPublisher{``1})">
            <summary>
            Delays the actual subscription to the source IFlux until the other IPublisher signals an
            OnNext or OnComplete.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="U">The other value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="other">The other IPublisher which should trigger the actual subscription.</param>
            <returns></returns>
        </member>
        <member name="M:Reactor.Core.Flux.Dematerialize``1(Reactor.Core.IFlux{Reactor.Core.ISignal{``0}})">
            <summary>
            Transforms a sequence of ISignal instances back into OnNext, OnError and OnComplete signals.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux with ISignal type.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Distinct``1(Reactor.Core.IFlux{``0})">
            <summary>
            Makes sure only distinct elements are relayed through the lifetime of the IFlux sequence,
            as determined by the default <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/> comparer.
            </summary>
            <remarks>
            Note that the internal HashSet used for remembering seen elements can't be cleared
            and may grow indefinitely.
            </remarks>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Distinct``1(Reactor.Core.IFlux{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Makes sure only distinct elements are relayed through the lifetime of the IFlux sequence,
            as determined by the given comparer.
            </summary>
            <remarks>
            Note that the internal HashSet used for remembering seen elements can't be cleared
            and may grow indefinitely.
            </remarks>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="comparer">The comparer comparing the source elements</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Distinct``2(Reactor.Core.IFlux{``0},System.Func{``0,``1})">
            <summary>
            Makes sure only distinct elements (according to a key) are relayed through the lifetime of the IFlux sequence,
            as determined by the <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/> key comparer.
            </summary>
            <remarks>
            Note that the internal HashSet used for remembering seen keys can't be cleared
            and may grow indefinitely.
            </remarks>
            <typeparam name="T">The value type.</typeparam>
            <typeparam name="K">The key type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="keySelector">The function that extracts the key from the source value to be checked for distinctness.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Distinct``2(Reactor.Core.IFlux{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Makes sure only distinct elements (according to a key) are relayed through the lifetime of the IFlux sequence,
            as determined by the given comparer. default <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/> comparer.
            </summary>
            <remarks>
            Note that the internal HashSet used for remembering seen keys can't be cleared
            and may grow indefinitely.
            </remarks>
            <typeparam name="T">The value type.</typeparam>
            <typeparam name="K">The key type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="keySelector">The function that extracts the key from the source value to be checked for distinctness.</param>
            <param name="comparer">The comparer comparing the extracted keys.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.DistinctUntilChanged``1(Reactor.Core.IFlux{``0})">
            <summary>
            Makes sure a source IFlux item is only relayed if it doesn't equal to the previous
            element, based on the default <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/> comparer.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.DistinctUntilChanged``1(Reactor.Core.IFlux{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Makes sure a source IFlux item is only relayed if it doesn't equal to the previous
            element, based on the give comparer.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="comparer">The comparer to compare subsequent source items.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.DistinctUntilChanged``2(Reactor.Core.IFlux{``0},System.Func{``0,``1})">
            <summary>
            Makes sure a source IFlux item is only relayed if the key extracted from it doesn't equal to the previous
            element's key, based on the default <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/> key comparer.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="K">The key type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="keySelector">The function that extracts a key from the source item.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.DistinctUntilChanged``2(Reactor.Core.IFlux{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Makes sure a source IFlux item is only relayed if the key extracted from it doesn't equal to the previous
            element's key, based on the given key comparer.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="K">The key type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="keySelector">The function that extracts a key from the source item.</param>
            <param name="comparer">The comparer to compare the extracted keys of subsequent source items.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.DoAfterTerminate``1(Reactor.Core.IFlux{``0},System.Action)">
            <summary>
            Call the specified action after the source has signalled an OnError or OnComplete.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="onAfterTerminate">The action to call.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.DoAfterNext``1(Reactor.Core.IFlux{``0},System.Action{``0})">
            <summary>
            Call the specified action with the current value after the source has signalled an OnNext.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="onAfterNext">The action to call.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.DoOnCancel``1(Reactor.Core.IFlux{``0},System.Action)">
            <summary>
            Call the specified action if the sequence gets cancelled.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="onCancel">The action to call.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.DoOnComplete``1(Reactor.Core.IFlux{``0},System.Action)">
            <summary>
            Call the specified action before the source signals an OnComplete.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="onComplete">The action to call.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.DoOnError``1(Reactor.Core.IFlux{``0},System.Action{System.Exception})">
            <summary>
            Call the specified action before the source signals an OnError.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="onError">The action to call.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.DoOnError``2(Reactor.Core.IFlux{``0},System.Action{``1})">
            <summary>
            Call the specified action before the source signals OnError with the given Exception type (or its subtypes).
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <typeparam name="E">The exception type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="onError">The action to call.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.DoOnError``1(Reactor.Core.IFlux{``0},System.Func{System.Exception,System.Boolean},System.Action{System.Exception})">
            <summary>
            Call the specified action before the source signals an OnError whose Exception matches the predicate.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="predicate">The predicate that receives the Exception and if returns true, the onError action is called.</param>
            <param name="onError">The action to call.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.DoOnNext``1(Reactor.Core.IFlux{``0},System.Action{``0})">
            <summary>
            Calls the specified action with the current value before the sequence signals an OnNext.
            </summary>
            <typeparam name="T">The value type</typeparam>
            <param name="source">The source IFlux</param>
            <param name="onNext">The action to call with the current value.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.DoOnRequest``1(Reactor.Core.IFlux{``0},System.Action{System.Int64})">
            <summary>
            Calls the specified action with the current request amount before it reaches the upstream.
            </summary>
            <typeparam name="T">The value type</typeparam>
            <param name="source">The source IFlux</param>
            <param name="onRequest">The action to call.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.DoOnSubscribe``1(Reactor.Core.IFlux{``0},System.Action{Reactive.Streams.ISubscription})">
            <summary>
            Calls the specified action with the incoming ISubscription before it reaches the downstream.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="onSubscribe">The action to call.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.DoOnTerminate``1(Reactor.Core.IFlux{``0},System.Action)">
            <summary>
            Calls the specified action befoer the source signals an OnError or OnComplete.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="onTerminate">The action to call.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Elapsed``1(Reactor.Core.IFlux{``0})">
            <summary>
            Wraps each source element into a Timed structure which holds the time difference between
            subsequent element according to the default timed scheduler. The first structure holds
            the time between the subscription and the emission of the first element.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Elapsed``1(Reactor.Core.IFlux{``0},Reactor.Core.TimedScheduler)">
            <summary>
            Wraps each source element into a Timed structure which holds the time difference between
            subsequent element according to the given timed scheduler. The first structure holds
            the time between the subscription and the emission of the first element.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="scheduler">The scheduler supplying the notion of current time.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.ElementAt``1(Reactor.Core.IFlux{``0},System.Int64)">
            <summary>
            Emits the element at the given index or signals an IndexOutOfRangeException if
            the sequence is shorter.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="index">The index of the element to return.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.ElementAt``1(Reactor.Core.IFlux{``0},System.Int64,``0)">
            <summary>
            Emits the element at the given index or signals a default value if
            the sequence is shorter.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="index">The index of the element to return.</param>
            <param name="defaultValue">The value to signal if the sequence is shorter.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Every``1(Reactor.Core.IFlux{``0},System.Int32)">
            <summary>
            Returns every <paramref name="batchSize"/> element from the source sequence
            or the very last element (if the source length not multiple of the batchSize).
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="batchSize">The frequency of elements to return.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.EveryFirst``1(Reactor.Core.IFlux{``0},System.Int32)">
            <summary>
            Returns every <paramref name="batchSize"/> element, starting from the first element from
            the source sequence.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="batchSize">The frequency of elements to return.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Filter``1(Reactor.Core.IFlux{``0},System.Func{``0,System.Boolean})">
            <summary>
            Filters out elements that don't match the predicate.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux</param>
            <param name="predicate">The predicate function called for each source element and returns true if that element
            may pass.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.FirstEmittingWith``1(Reactor.Core.IFlux{``0},Reactive.Streams.IPublisher{``0})">
            <summary>
            Relays signals of the source IFlux or the other IPublisher sequence whichever signals first,
            cancelling the other (or not even subscribing to it).
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="other">The other IPublisher.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.FlatMap``2(Reactor.Core.IFlux{``0},System.Func{``0,Reactive.Streams.IPublisher{``1}},System.Boolean)">
            <summary>
            Flattens (merges) a sequence of IPublisher sources generated via a mapper function from the source elements, optionally
            delaying any errors.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="R">The result value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="mapper">The function that receives a source value and returns an IPublisher to be merged</param>
            <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
            signalling an AggregateException if there were more than one Exception.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.FlatMap``2(Reactor.Core.IFlux{``0},System.Func{``0,Reactive.Streams.IPublisher{``1}},System.Int32,System.Boolean)">
            <summary>
            Flattens (merges) a sequence of IPublisher sources generated via a mapper function from the source elements, 
            making sure only the specified number of sources are active and optionally
            delaying any errors.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="R">The result value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="mapper">The function that receives a source value and returns an IPublisher to be merged</param>
            <param name="maxConcurrency">The maximum number of active IPublisher sources at the same time.</param>
            <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
            signalling an AggregateException if there were more than one Exception.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.FlatMap``2(Reactor.Core.IFlux{``0},System.Func{``0,Reactive.Streams.IPublisher{``1}},System.Int32,System.Int32,System.Boolean)">
            <summary>
            Flattens (merges) a sequence of IPublisher sources generated via a mapper function from the source elements, 
            making sure only the specified number of sources are active, prefetching the specified amount from each
            and optionally delaying any errors.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="R">The result value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="mapper">The function that receives a source value and returns an IPublisher to be merged</param>
            <param name="maxConcurrency">The maximum number of active IPublisher sources at the same time.</param>
            <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
            unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
            <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
            signalling an AggregateException if there were more than one Exception.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.FlatMap``2(Reactor.Core.IFlux{``0},System.Func{``0,Reactive.Streams.IPublisher{``1}},System.Func{System.Exception,Reactive.Streams.IPublisher{``1}},System.Func{Reactive.Streams.IPublisher{``1}})">
            <summary>
            Flattens (merges) a sequence of IPublisher sources generated via a mapper function from the source elements and terminal signals.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="R">The result value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="mapperOnNext">The function that receives each source elements and returns an IPublisher for them to be merged.</param>
            <param name="mapperOnError">The function that receives the Exception and returns an IPublisher for it to be merged.</param>
            <param name="mapperOnComplete">The function that is called when the source completes and returns an IPublisher for it to be merged.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.FlatMap``2(Reactor.Core.IFlux{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Flattens (merges) IEnumerable sequences generated by a mapper function from the values of the source IPublisher.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="R">The result value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="mapper">The function that maps each source value into an IEnumerable.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.FlatMap``2(Reactor.Core.IFlux{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Int32)">
            <summary>
            Flattens (merges) IEnumerable sequences generated by a mapper function from the values of the source IPublisher.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="R">The result value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="mapper">The function that maps each source value into an IEnumerable.</param>
            <param name="prefetch">The number of items to prefetch from the source. If negative, the source is run in
            unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.GroupBy``2(Reactor.Core.IFlux{``0},System.Func{``0,``1})">
            <summary>
            Groups elements with the same key into an IGroupedFlux inner sequences.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="K">The key type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="keySelector">The function that extracts a key from a source element.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.GroupBy``3(Reactor.Core.IFlux{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <summary>
            Groups values, extracted from elements, with the same key into IGroupedFlux inner sequences.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="K">The key type.</typeparam>
            <typeparam name="V">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="keySelector">The function that extracts a key from a source element.</param>
            <param name="valueSelector">The function that extracts the value from a source element.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.GroupBy``3(Reactor.Core.IFlux{``0},System.Func{``0,``1},System.Func{``0,``2},System.Int32)">
            <summary>
            Groups values, extracted from elements, with the same key into IGroupedFlux inner sequences.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="K">The key type.</typeparam>
            <typeparam name="V">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="keySelector">The function that extracts a key from a source element.</param>
            <param name="valueSelector">The function that extracts the value from a source element.</param>
            <param name="prefetch">The number of items to prefetch from the source. If negative, the source is run in
            unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.HasElement``1(Reactor.Core.IFlux{``0},``0)">
            <summary>
            Signals a single true if the source has the specified element, based on
            the <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/> comparer.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="element">The element to look for.</param>
            <returns>The new IMono instance</returns>
        </member>
        <member name="M:Reactor.Core.Flux.HasElement``1(Reactor.Core.IFlux{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Signals a single true if the source has the specified element, based on
            the given comparer.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="element">The element to look for.</param>
            <param name="comparer">The comparer to use to compare source elements with the given element.</param>
            <returns>The new IMono instance</returns>
        </member>
        <member name="M:Reactor.Core.Flux.HasElements``1(Reactor.Core.IFlux{``0})">
            <summary>
            Signals a single true if the source IFlux sequence contains any elements (i.e., it's not empty).
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Hide``1(Reactor.Core.IFlux{``0})">
            <summary>
            Hides the external and internal identity of the source sequence; useful
            to break identity based macro- and micro-optimizations.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.IgnoreElements``1(Reactor.Core.IFlux{``0})">
            <summary>
            Ignores OnNext signals from the source and only relays the terminal signals.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <param name="source">The source IFlux to ignore elements of.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Last``1(Reactor.Core.IFlux{``0})">
            <summary>
            Returns the last element from the source sequence or signal IndexOutOfRangeException.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.MapError``1(Reactor.Core.IFlux{``0},System.Func{System.Exception,System.Exception})">
            <summary>
            Maps the Exception in the OnError signal via a mapper function.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="mapper">The function that receives the Exception from the source and returns an Exception in exchange.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.MapError``2(Reactor.Core.IFlux{``0},System.Func{``1,System.Exception})">
            <summary>
            Maps the Exception in the OnError signal, if it is of the specified type, via a mapper function.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <typeparam name="E">The Exception type to map.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="mapper">The function that is called if the upstream Exception is of the specified 
            type and returns an Exception in exchange.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.MapError``1(Reactor.Core.IFlux{``0},System.Func{System.Exception,System.Boolean},System.Func{System.Exception,System.Exception})">
            <summary>
            Maps the Exception in the OnError signal, if it matches a predicate, via a mapper function.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="predicate">The predicate called with the upstream Exception and if returns true, the <paramref name="mapper"/> is called.</param>
            <param name="mapper">The function called with the upstream Exception, if the predicate matched, and returns an Exception in exchange.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Materialize``1(Reactor.Core.IFlux{``0})">
            <summary>
            Converts the signal types of the source IFlux into ISignal elements.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <returns>The new IFlux with ISignal element type.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.MergeWith``1(Reactor.Core.IFlux{``0},Reactive.Streams.IPublisher{``0})">
            <summary>
            Merges the elements of the source IFlux with the other IPublisher into a single, flat sequence.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="other">The other IPublisher</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Next``1(Reactor.Core.IFlux{``0})">
            <summary>
            Signals the first element, if any, from the source IFlux.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.OnBackpressureBuffer``1(Reactor.Core.IFlux{``0})">
            <summary>
            Runs the source sequence in unbounded mode and buffers elements until the
            downstream requests more.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.OnBackpressureDrop``1(Reactor.Core.IFlux{``0},System.Action{``0})">
            <summary>
            Runs the source sequence in unbounded mode and drops elements if the
            downstream didn't request enough or in time.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="onDrop">The action to call with the dropped element.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.OnBackpressureError``1(Reactor.Core.IFlux{``0})">
            <summary>
            Runs the source sequence in unbounded mode and signals an InvalidOperationException
            if the downstream didn't request enough or in time.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.OnBackpressureLatest``1(Reactor.Core.IFlux{``0})">
            <summary>
            Runs the sequence in unbounded mode and signals the latest element from it
            when teh downstream requests. Unclaimed elements are overwritten.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.OnErrorResumeWith``1(Reactor.Core.IFlux{``0},System.Func{System.Exception,Reactive.Streams.IPublisher{``0}})">
            <summary>
            If the source signals an OnError, call the supplied function with the Exception and continue
            with the returned IPublisher sequence.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="resumeFunction">The function that receives the Exception and returns an IPublisher for continuing the sequence.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.OnErrorResumeWith``2(Reactor.Core.IFlux{``0},System.Func{``1,Reactive.Streams.IPublisher{``0}})">
            <summary>
            If the source signals an OnError with an Exception of the given type, call the supplied 
            function with the Exception and continue with the returned IPublisher sequence.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <typeparam name="E">The exception type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="resumeFunction">The function that receives the Exception of the specified type
            and returns an IPublisher for continuing the sequence.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.OnErrorResumeWith``1(Reactor.Core.IFlux{``0},System.Func{System.Exception,System.Boolean},System.Func{System.Exception,Reactive.Streams.IPublisher{``0}})">
            <summary>
            If the source signals an OnError and the Exception matches a predicate, call the supplied function 
            with the Exception and continue with the returned IPublisher sequence.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="predicate">The predicate called with the OnError Exception and returns true if the <paramref name="resumeFunction"/>
            can be called with that Exception.</param>
            <param name="resumeFunction">The function that receives the Exception and returns an IPublisher for continuing the sequence.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.OnErrorReturn``1(Reactor.Core.IFlux{``0},``0)">
            <summary>
            Signals a last value and completes the sequence in place of an OnError signal.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="value">The value to signal at last instead of an OnError.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.OnErrorReturn``2(Reactor.Core.IFlux{``0},``0)">
            <summary>
            Signals a last value and completes the sequence in place of an OnError signal whose Exception type
            matches the specified type.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <typeparam name="E">The exception type to match.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="value">The value to signal at last instead of an OnError.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.OnErrorReturn``1(Reactor.Core.IFlux{``0},System.Func{System.Exception,System.Boolean},``0)">
            <summary>
            Signals a last value and completes the sequence in place of an OnError signal in case
            the Exception matches the given predicate.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="predicate">The predicate called with the Exception and if it returns true, the sequence is terminated
            with the <paramref name="value"/>.</param>
            <param name="value">The value to signal at last instead of an OnError.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.OnTerminateDetach``1(Reactor.Core.IFlux{``0})">
            <summary>
            Detaches the references between the upstream and downstream (the upstreams ISubscription
            and the downstreams ISubscriber), allowing both to be garbage collected early.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Process``1(Reactor.Core.IFlux{``0},Reactive.Streams.IProcessor{``0,``0})">
            <summary>
            Drive the source sequence through the given processor when the connection is established
            via <see cref="M:Reactor.Core.IConnectableFlux`1.Connect(System.Action{System.IDisposable})"/> call to the returned
            IConnectableFlux. Note that this is may be a one-time operation depeneding on
            how the processor handles terminal signals.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="processor">The processor to signal the events at and subscribe to.</param>
            <returns>The new IConnectableFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Process``1(Reactor.Core.IFlux{``0},System.Func{Reactive.Streams.IProcessor{``0,``0}})">
            <summary>
            Drive the source sequence through the a processor returned by a supplier 
            when the connection is established
            via <see cref="M:Reactor.Core.IConnectableFlux`1.Connect(System.Action{System.IDisposable})"/> call to the returned
            IConnectableFlux. 
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="processorSupplier">The function called for each subscriber to return an IProcessor to run elements through.</param>
            <returns>The new IConnectableFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Process``2(Reactor.Core.IFlux{``0},Reactive.Streams.IProcessor{``0,``0},System.Func{Reactor.Core.IFlux{``0},Reactive.Streams.IPublisher{``1}})">
            <summary>
            Drive the source sequence through the given processor and an IPublisher returned by
            the selector function when the connection is established
            via <see cref="M:Reactor.Core.IConnectableFlux`1.Connect(System.Action{System.IDisposable})"/> call to the returned
            IConnectableFlux. Note that this is may be a one-time operation depeneding on
            how the processor handles terminal signals.
            </summary>
            <typeparam name="T">The input value type.</typeparam>
            <typeparam name="U">The output value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="processor">The processor to signal the events at and subscribe to.</param>
            <param name="selector">The function that receives the processor and returns an IPublisher to be the output.</param>
            <returns>The new IConnectableFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Process``2(Reactor.Core.IFlux{``0},System.Func{Reactive.Streams.IProcessor{``0,``0}},System.Func{Reactor.Core.IFlux{``0},Reactive.Streams.IPublisher{``1}})">
            <summary>
            Drive the source sequence through the a processor returned by a supplier and
            an IPublisher returned by the selector function when the connection is established
            via <see cref="M:Reactor.Core.IConnectableFlux`1.Connect(System.Action{System.IDisposable})"/> call to the returned
            IConnectableFlux. 
            </summary>
            <typeparam name="T">The input value type.</typeparam>
            <typeparam name="U">The output value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="processorSupplier">The function called for each subscriber to return an IProcessor to run elements through.</param>
            <param name="selector">The function that receives the processor returned by <paramref name="processorSupplier"/> and returns an IPublisher to be the output.</param>
            <returns>The new IConnectableFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Publish``1(Reactor.Core.IFlux{``0})">
            <summary>
            Shares an underlying connection to the source and dispatches signals to all subscribers currently
            subscribed to it.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <returns>The new IConnectableFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Publish``1(Reactor.Core.IFlux{``0},System.Int32)">
            <summary>
            Shares an underlying connection to the source and dispatches signals to all subscribers currently
            subscribed to it.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="prefetch">The number of items to prefetch from the source. If negative, the source is run in
            unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
            <returns>The new IConnectableFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Publish``2(Reactor.Core.IFlux{``0},System.Func{Reactor.Core.IFlux{``0},Reactive.Streams.IPublisher{``1}})">
            <summary>
            Shares a single underlying connection, for each downstream subscriber, to the source 
            IFlux for the duration of the transformer function and emits the signals of the returned
            IPublisher of this transformer function.
            </summary>
            <typeparam name="T">The input value type.</typeparam>
            <typeparam name="R">The output value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="transformer">The function that receives a shared IFlux instance that can
            be freely subscribed to as many times as wanted without causing multiple subscriptions to <paramref name="source"/>
            and returns an IPublisher to be the signaller of the resulting signals.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Publish``2(Reactor.Core.IFlux{``0},System.Func{Reactor.Core.IFlux{``0},Reactive.Streams.IPublisher{``1}},System.Int32)">
            <summary>
            Shares a single underlying connection, for each downstream subscriber, to the source 
            IFlux for the duration of the transformer function and emits the signals of the returned
            IPublisher of this transformer function.
            </summary>
            <typeparam name="T">The input value type.</typeparam>
            <typeparam name="R">The output value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="transformer">The function that receives a shared IFlux instance that can
            be freely subscribed to as many times as wanted without causing multiple subscriptions to <paramref name="source"/>
            and returns an IPublisher to be the signaller of the resulting signals.</param>
            <param name="prefetch">The number of items to prefetch from the source. If negative, the source is run in
            unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.PublishNext``1(Reactor.Core.IFlux{``0})">
            <summary>
            Prepare an IMono which shares the source IFlux
            sequence and dispatches the first observed item to
            subscribers in a backpressure-aware manner.
            This will effectively turn any type of sequence into a hot sequence 
            when the first ISubscriber subscribes.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.PublishOn``1(Reactor.Core.IFlux{``0},Reactor.Core.Scheduler,System.Boolean)">
            <summary>
            Signals the events of the source IFlux on the specified scheduler, that is,
            the observation of that events downstream will happen on the thread provided
            by the scheduler.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="scheduler">The Scheduler to use to emit signals on.</param>
            <param name="delayError">If true, OnError signals won't skip ahead of the OnNext signals.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.PublishOn``1(Reactor.Core.IFlux{``0},Reactor.Core.Scheduler,System.Int32,System.Boolean)">
            <summary>
            Signals the events of the source IFlux on the specified scheduler, that is,
            the observation of that events downstream will happen on the thread provided
            by the scheduler.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="scheduler">The Scheduler to use to emit signals on.</param>
            <param name="prefetch">The number of items to prefetch from the source. If negative, the source is run in
            unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
            <param name="delayError">If true, OnError signals won't skip ahead of the OnNext signals.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Reduce``1(Reactor.Core.IFlux{``0},System.Func{``0,``0,``0})">
            <summary>
            Reduces the sequence of values into a single value by applying a reducer function
            to a running accumulator value and a current value.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="reducer">The function that receives the previous accumulator value (or the first value) 
            and the current value and returns a new accumulator value.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Reduce``2(Reactor.Core.IFlux{``0},``1,System.Func{``1,``0,``1})">
            <summary>
            Reduces a sequence of values into a single value by starting from an initial
            accumulator value and applying a reducer function to the running
            accumulator value and the current source element.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="A">The accumulated value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="initial">The initial accumulator value.</param>
            <param name="reducer">The function that receives the current accumulator value, the current source element
            and returns a new accumulator value.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.ReduceWith``2(Reactor.Core.IFlux{``0},System.Func{``1},System.Func{``1,``0,``1})">
            <summary>
            Reduces a sequence of values into a single value by starting from an initial
            accumulator value supplied by a function and applying a reducer function to the running
            accumulator value and the current source element.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="A">The accumulated value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="initialSupplier">The function that returns initial accumulator value for each subscriber.</param>
            <param name="reducer">The function that receives the current accumulator value, the current source element
            and returns a new accumulator value.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Repeat``1(Reactor.Core.IFlux{``0})">
            <summary>
            Repeatedly subscribes to the source sequence and relays its signals if
            it completes normally.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Repeat``1(Reactor.Core.IFlux{``0},System.Int64)">
            <summary>
            Repeatedly, but at most <paramref name="times"/>, subscribes to the source sequence and relays its signals if
            it completes normally.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="times">Number of times to repeat, 0 means run the source once.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Repeat``1(Reactor.Core.IFlux{``0},System.Func{System.Boolean})">
            <summary>
            Repeatedly subscribes to the source sequence and relays its signals if
            it completes normally and the predicate returns true.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="predicate">The predicate to call when the source completes normally to determine if a repeat should happen.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Repeat``1(Reactor.Core.IFlux{``0},System.Int64,System.Func{System.Boolean})">
            <summary>
            Repeatedly subscribes to the source sequence and relays its signals if
            it completes normally and the predicate returns true and at most <paramref name="times"/>.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="times">Number of times to repeat, 0 means run the source once.</param>
            <param name="predicate">The predicate to call when the source completes normally to determine if a repeat should happen.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.RepeatWhen``1(Reactor.Core.IFlux{``0},System.Func{Reactor.Core.IFlux{System.Int64},Reactive.Streams.IPublisher{System.Object}})">
            <summary>
            Repeatedly subscribes to the source when the source completes normally and 
            the IPublisher returned by the <paramref name="whenFunction"/>
            signals any OnNext value. Any other signals from this IPublisher terminates
            the sequence with that signal type.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="whenFunction">The function that receives an IFlux that signals the number
            of items emitted in the previous run and returns an IPublisher that has to signal
            OnNext to repeat the subscription to the source or a terminal event to terminate the
            whole sequence.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Replay``1(Reactor.Core.IFlux{``0})">
            <summary>
            Replays all of the signals of the source IFlux from the very beginning to subscribers.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux</param>
            <returns>The new IConnectableFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Replay``1(Reactor.Core.IFlux{``0},System.Int32)">
            <summary>
            Replays the last specified number of items plus the terminal signal from the IFlux
            to subscribers.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="history">The number of last items to replay.</param>
            <returns>The new IConnectableFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Replay``2(Reactor.Core.IFlux{``0},System.Func{Reactor.Core.IFlux{``0},Reactive.Streams.IPublisher{``1}})">
            <summary>
            Shares a single underlying connection, established for each subscriber, to
            the underlying source and applies a transformation function to derive the
            output sequence.
            </summary>
            <typeparam name="T">The input value type.</typeparam>
            <typeparam name="R">The output value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="transformer">The function that receives a shared IFlux instance that can
            be freely subscribed to as many times as wanted without causing multiple subscriptions to <paramref name="source"/>
            and returns an IPublisher to be the signaller of the resulting signals.</param>
            <returns>THe new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Retry``1(Reactor.Core.IFlux{``0})">
            <summary>
            Retries the given source IFlux if it signals any OnError.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Retry``1(Reactor.Core.IFlux{``0},System.Int64)">
            <summary>
            Retries the given source IFlux if it signals any OnError at most the
            specified number of times.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="times">The retry amount, 0 retry means don't retry on error.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Retry``1(Reactor.Core.IFlux{``0},System.Func{System.Exception})">
            <summary>
            Retries the given source IFlux if it signals any OnError if
            the predicate returns true.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="predicate">The function to return true to retry the source in case of an OnError signal.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Retry``1(Reactor.Core.IFlux{``0},System.Int64,System.Func{System.Exception})">
            <summary>
            Retries the given source IFlux if it signals any OnError if
            the predicate returns true and at most the specified number of
            times.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="times">The retry amount, 0 retry means don't retry on error.</param>
            <param name="predicate">The function to return true to retry the source in case of an OnError signal.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.RetryWhen``1(Reactor.Core.IFlux{``0},System.Func{Reactor.Core.IFlux{System.Exception},Reactive.Streams.IPublisher{System.Object}})">
            <summary>
            Retries the source if the IPublisher returned by the <paramref name="whenFunction"/> signals
            an OnNext value.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="whenFunction">Function that is called for each subscriber with a IFlux
            that emits the OnError signal from the source and returns an IPublisher. If this IPublisher signals
            an OnNext, the source is retried or if it signals a terminal event, the sequence is terminated.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Sample``1(Reactor.Core.IFlux{``0},System.TimeSpan)">
            <summary>
            Samples the latest value from the source IFlux at the specified time intervals.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="timespan">The time interval to sample the source. If the source is
            empty at that point, nothing is emitted.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Sample``1(Reactor.Core.IFlux{``0},System.TimeSpan,Reactor.Core.TimedScheduler)">
            <summary>
            Samples the latest value from the source IFlux at the specified time intervals run
            by the given timed scheduler.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="timespan">The time interval to sample the source. If the source is
            empty at that point, nothing is emitted.</param>
            <param name="scheduler">The timed scheduler to do the periodic sampling and
            emission of the sampled value.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Sample``2(Reactor.Core.IFlux{``0},Reactive.Streams.IPublisher{``1})">
            <summary>
            Samples the latest value from the source IFlux whenever the other IPublisher signals an OnNext.
            </summary>
            <typeparam name="T">The main value type.</typeparam>
            <typeparam name="U">The other value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="sampler">The sampler IPublisher.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.SampleFirst``1(Reactor.Core.IFlux{``0},System.TimeSpan)">
            <summary>
            Samples the first values from the source IFlux at the specified time intervals.
            </summary>
            <typeparam name="T">The value type</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="timespan">The sampling time interval.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.SampleFirst``1(Reactor.Core.IFlux{``0},System.TimeSpan,Reactor.Core.TimedScheduler)">
            <summary>
            Samples the first values from the source IFlux at the specified time intervals,
            running on the specified timed scheduler.
            </summary>
            <typeparam name="T">The value type</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="timespan">The sampling time interval.</param>
            <param name="scheduler">The timed scheduler to do the periodic sampling and
            emission of the sampled value.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.SampleFirst``2(Reactor.Core.IFlux{``0},System.Func{``0,Reactive.Streams.IPublisher{``1}})">
            <summary>
            Samples a values from the source IFlux and ignores subsequent values until the sampler
            generated for the sampled value signals an OnNext or OnComplete.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="U">The sampler value type.</typeparam>
            <param name="source">The source IFlux</param>
            <param name="samplerFactory">The function that takes the sampled value and returns an IPublisher that
            has to signal an OnNext or OnComplete to allow the sampling of the next source value.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.SampleTimeout``1(Reactor.Core.IFlux{``0},System.TimeSpan)">
            <summary>
            Signals (debounces) the latest OnNext value if no new OnNext value is signalled from the source IFlux
            in the specified timespan.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="timespan">The time to wait after an OnNext signal from the source.</param>
            <returns>THe new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.SampleTimeout``1(Reactor.Core.IFlux{``0},System.TimeSpan,Reactor.Core.TimedScheduler)">
            <summary>
            Signals (debounces) the latest OnNext value if no new OnNext value is signalled from the source IFlux
            in the specified timespan, run on the specified timed scheduler.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="timespan">The time to wait after an OnNext signal from the source.</param>
            <param name="scheduler">The timed scheduler to do the periodic sampling and
            emission of the sampled value.</param>
            <returns>THe new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.SampleTimeout``2(Reactor.Core.IFlux{``0},System.Func{``0,Reactive.Streams.IPublisher{``1}})">
            <summary>
            Signals (debounces) the latest OnNext signal from the source IFlux if no other OnNext signals arrive
            from the source during the time the associated IPublisher signals an OnNext or OnComplete.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="U">The sampler value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="samplerFactory">The function called with the source value and returns an IPublisher which
            emits that source value when it signals an OnNext or OnComplete and the source didn't signal a new OnNext
            in the meantime.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Scan``1(Reactor.Core.IFlux{``0},System.Func{``0,``0,``0})">
            <summary>
            Performs a running aggregation on the source IFlux via a scanner function and emits the
            intermediate values.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="scanner">The function receiving the accumulated value (or the first source value) and
            the current value and returns a new accumulated value.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Scan``2(Reactor.Core.IFlux{``0},``1,System.Func{``1,``0,``1})">
            <summary>
            Performs a running aggregation on the source IFlux via a scanner function and emits the
            intermediate values, starting with an initial accumulator value.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <typeparam name="A">The accumulator and result type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="initial">The initial accumulator value. Note this is shared across all subscribers.</param>
            <param name="scanner">The function receiving the accumulated value (or the initial value) and
            the current value and returns a new accumulated value.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.ScanWith``2(Reactor.Core.IFlux{``0},System.Func{``1},System.Func{``1,``0,``1})">
            <summary>
            Performs a running aggregation on the source IFlux via a scanner function and emits the
            intermediate values, starting with an initial accumulator value for each subscriber.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <typeparam name="A">The accumulator and result type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="initialSupplier">The function that generates the initial accumulator value for each subscriber.</param>
            <param name="scanner">The function receiving the accumulated value (or the initial value) and
            the current value and returns a new accumulated value.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Single``1(Reactor.Core.IFlux{``0})">
            <summary>
            Expects the source to be single-valued and returns an IMono for it. If
            the source is empty or has more than one element, an IndexOutOfRangeException is
            signalled.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Single``1(Reactor.Core.IFlux{``0},``0)">
            <summary>
            Expects the source to be zero or single-valued and returns an IMono for it. If
            the source is empty, the given defaultValue is signalled. If the source has more 
            than one element, an IndexOutOfRangeException is signalled.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="defaultValue">The value to signal if the source is empty.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.SingleOrEmpty``1(Reactor.Core.IFlux{``0})">
            <summary>
            Signals the single value or OnComplete if the source has exactly one item or is empty, or
            signals an IndexOutOfRangeException if the source has more than one item.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Skip``1(Reactor.Core.IFlux{``0},System.Int64)">
            <summary>
            Skips the first number of items from the source IFlux sequence.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="n">The number of items to skip from the beginning.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Skip``1(Reactor.Core.IFlux{``0},System.TimeSpan)">
            <summary>
            Skips items from the beginning source IFlux during the specified timespan.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="timespan">The time duration while to skip the items from the source.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Skip``1(Reactor.Core.IFlux{``0},System.TimeSpan,Reactor.Core.TimedScheduler)">
            <summary>
            Skips items from the beginning source IFlux during the specified timespan
            as run on the specified timed scheduler.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="timespan">The time duration while to skip the items from the source.</param>
            <param name="scheduler">The timed scheduler to use for the timed skipping.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.SkipLast``1(Reactor.Core.IFlux{``0},System.Int64)">
            <summary>
            Skips the last given number of items from the source IFlux.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="n">The number of last items to skip.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.SkipUntil``2(Reactor.Core.IFlux{``0},Reactive.Streams.IPublisher{``1})">
            <summary>
            Skips items from the source IFlux until the other IPublisher signals an
            OnNext or OnComplete signal.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="U">The other value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="other">The other IPublisher that signals OnNext or OnComplete, allowing the subsequent
            main source items to flow through.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.SkipWhile``1(Reactor.Core.IFlux{``0},System.Func{``0,System.Boolean})">
            <summary>
            Skips the first items while the predicate returns true for them.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="predicate">The predicate called with the current item and returns true to skip that item.
            If it returns false, all subsequent items from the source are passed along without futher calls to this predicate.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.StartWith``1(Reactor.Core.IFlux{``0},``0[])">
            <summary>
            Emits the given items before the source IFlux.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="values">The values to signal before the source IFlux items.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.StartWith``1(Reactor.Core.IFlux{``0},System.Collections.Generic.IEnumerable{``0},System.Boolean)">
            <summary>
            Emits items from an IEnumerable before the source IFlux.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="values">The values to signal before the source IFlux items.</param>
            <param name="delayError">Should any error of the IEnumerable be delayed after the termination of the source IFlux?</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.StartWith``1(Reactor.Core.IFlux{``0},Reactive.Streams.IPublisher{``0},System.Boolean)">
            <summary>
            Emits items from the other IPublisher before the source IFlux.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="other">The other IPublisher whose values have to be signalled before the source IFlux.</param>
            <param name="delayError">Should any error of the IPublisher be delayed after the termination of the source IFlux?</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.SubscribeOn``1(Reactor.Core.IFlux{``0},Reactor.Core.Scheduler)">
            <summary>
            Calls Subscribe() and Request() of the source IFlux on a thread provided by the specified scheduler.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="scheduler">The scheduler that provides the thread to call Subscribe() and Request() on.</param>
            <returns>The new IFlux isntance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.SwitchMap``2(Reactor.Core.IFlux{``0},System.Func{``0,Reactive.Streams.IPublisher{``1}})">
            <summary>
            Switches to a new inner IPublisher, generated by a mapper function, whenever the source
            emits an OnNext, cancelling the previous IPublisher if any.
            </summary>
            <typeparam name="T">The input value type.</typeparam>
            <typeparam name="R">The output value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="mapper">The function that receives the source item and returns an IPublisher whose items are then 
            relayed until the main source signals another item.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.SwitchMap``2(Reactor.Core.IFlux{``0},System.Func{``0,Reactive.Streams.IPublisher{``1}},System.Int32)">
            <summary>
            Switches to a new inner IPublisher, generated by a mapper function, whenever the source
            emits an OnNext, cancelling the previous IPublisher if any.
            </summary>
            <typeparam name="T">The input value type.</typeparam>
            <typeparam name="R">The output value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="mapper">The function that receives the source item and returns an IPublisher whose items are then 
            relayed until the main source signals another item.</param>
            <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
            unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.SwitchIfEmpty``1(Reactor.Core.IFlux{``0},Reactive.Streams.IPublisher{``0})">
            <summary>
            Switches to the other IPublisher if the source turns out to be empty.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="other">The other IPublisher to resume with if the source is empty.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Take``1(Reactor.Core.IFlux{``0},System.Int64)">
            <summary>
            Takes the first number of items from the source and completes the sequence.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="n">The number of items to take from the beginning.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Take``1(Reactor.Core.IFlux{``0},System.TimeSpan)">
            <summary>
            Takes the items from the beginning during the specified timespan interval.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="timespan">The duration timespan to allow source items to pass through.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Take``1(Reactor.Core.IFlux{``0},System.TimeSpan,Reactor.Core.TimedScheduler)">
            <summary>
            Takes the items from the beginning during the specified timespan interval,
            run on the specified timed scheduler.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="timespan">The duration timespan to allow source items to pass through.</param>
            <param name="scheduler">The timed scheduler to use for timing the duration.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.TakeLast``1(Reactor.Core.IFlux{``0},System.Int64)">
            <summary>
            Signals the last number of items only from the source IFlux.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="n">The number of last items to signal.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.TakeUntil``2(Reactor.Core.IFlux{``0},Reactive.Streams.IPublisher{``1})">
            <summary>
            Allows elements from the source IFlux to pass through until the 
            other IPublisher signals an OnNext or OnComplete which completes the
            sequence.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="U">The other value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="other">The other IPublisher that signals an OnNext or OnComplete to stop the main source .</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.TakeUntil``1(Reactor.Core.IFlux{``0},System.Func{``0,System.Boolean})">
            <summary>
            Allows elements from the source IFlux to pass through and checks the predicate
            to stop the sequence or not.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="predicate">The predicate called after the emission of each source item, with
            that item and returns true if the sequence has to be completed.</param>
            <returns></returns>
        </member>
        <member name="M:Reactor.Core.Flux.TakeWhile``1(Reactor.Core.IFlux{``0},System.Func{``0,System.Boolean})">
            <summary>
            Allows elements to pass through if the predicate, called before emission, returns true for that element
            or stops if the predicate returns false.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="predicate">The predicate called before emission with the current element from
            the source and if returns true, the element is signalled. Otherwise, the sequence is completed.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Then``1(Reactor.Core.IFlux{``0})">
            <summary>
            Returns an IMono that signals only the terminal signals from the source IFlux.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Then``1(Reactor.Core.IFlux{``0},Reactive.Streams.IPublisher{Reactor.Core.Void})">
            <summary>
            Runs the other, empty IPublisher instance when the source IFlux completes,
            ignoring their values and only signalling the terminal events.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="other">The other IPublisher.</param>
            <returns>The new IMono instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.ThenMany``2(Reactor.Core.IFlux{``0},Reactive.Streams.IPublisher{``1})">
            <summary>
            Runs the source IFlux to completion, ignoring its elements, then relays elements of
            the after IPublisher.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="R">The after value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="after">The IPublisher to run and relay signals of after the source.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Timeout``1(Reactor.Core.IFlux{``0},System.TimeSpan,Reactive.Streams.IPublisher{``0})">
            <summary>
            If the source doesn't produce subsequent items within the specified timeout, the
            sequence is switched to a fallback IPublisher or a TimeoutException is signalled.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="timeout">The timeout between source items.</param>
            <param name="fallback">The fallback IPublisher if the source times out. If null, a TimeoutException is signalled.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Timeout``1(Reactor.Core.IFlux{``0},System.TimeSpan,Reactor.Core.TimedScheduler,Reactive.Streams.IPublisher{``0})">
            <summary>
            If the source doesn't produce subsequent items within the specified timeout, the
            sequence is switched to a fallback IPublisher or a TimeoutException is signalled,
            where the timeout is determined by the given timed scheduler.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="timeout">The timeout between source items.</param>
            <param name="fallback">The fallback IPublisher if the source times out. If null, a TimeoutException is signalled.</param>
            <param name="scheduler">The timed scheduler giving the notion of the timeout.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Timeout``2(Reactor.Core.IFlux{``0},Reactive.Streams.IPublisher{``1},Reactive.Streams.IPublisher{``0})">
            <summary>
            If the source doesn't produce its first item before the other IPublisher signals an OnNext or
            OnComplete, the sequence is switched to the fallback IPublisher or a TimeoutException is signalled.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="U">The first timeout value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="firstTimeout">The timeout signaller for the first source item.</param>
            <param name="fallback">The fallback IPublisher if the source times out. If null, a TimeoutException is signalled.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Timeout``3(Reactor.Core.IFlux{``0},Reactive.Streams.IPublisher{``1},System.Func{``0,Reactive.Streams.IPublisher{``2}},Reactive.Streams.IPublisher{``0})">
            <summary>
            If the source doesn't signal its first or subsequent items before the associated timeout IPublishers
            signal an OnNext or OnError, the sequence is switched to the fallback IPublisher or a TimeoutException is signalled.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="U">The first timeout value type.</typeparam>
            <typeparam name="V">The subsequent timeout value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="firstTimeout">The timeout signaller for the first source item.</param>
            <param name="fallback">The fallback IPublisher if the source times out. If null, a TimeoutException is signalled.</param>
            <param name="itemTimeout">The function receives the previous source value and returns an IPublisher which signals
            timeout via OnNext or OnComplete.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Timestamp``1(Reactor.Core.IFlux{``0})">
            <summary>
            Wraps each source item into a structure that holds the current time when the item
            was received.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Timestamp``1(Reactor.Core.IFlux{``0},Reactor.Core.TimedScheduler)">
            <summary>
            Wraps each source item into a structure that holds the current time,
            as returned by the given timed scheduler, when the item
            was received.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="scheduler">The timed scheduler providing the current time.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.ToFlux``1(System.IObservable{``0},Reactor.Core.BackpressureHandling)">
            <summary>
            Convert an IObservable into an IFlux and apply a backpressure strategy to the sequence.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="backpressure">The backpressure strategy to apply. See <see cref="T:Reactor.Core.BackpressureHandling"/> enums.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.ToMono``1(Reactor.Core.IFlux{``0})">
            <summary>
            Converts this IFlux into an IMono.
            If the source flux has multiple values, only the very last is kept.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source to convert</param>
            <returns>The IFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.Flux.ToObservable``1(Reactor.Core.IFlux{``0})">
            <summary>
            Convert this IFlux into an IObservable.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <returns>The new IObservable.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Window``1(Reactor.Core.IFlux{``0},System.Int32)">
            <summary>
            Split this IFlux sequence into multiple IFlux delimited by the given maxSize
            count and starting from the first item.
            Each Flux bucket will onComplete after maxSize items have been routed.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="size">The maximum routed items before emitting onComplete per IFlux bucket.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Window``1(Reactor.Core.IFlux{``0},System.Int32,System.Int32)">
            <summary>
            Split this IFlux sequence into multiple IFlux delimited by the given {@code skip}
            count, starting from the first item.
            Each IFlux bucket will onComplete after {@code maxSize} items have been routed.
            </summary>
            <remarks>
            When skip > maxSize : dropping windows
            <p/>
            <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowsizeskip.png" alt=""/>
            <p/>
            When maxSize &lt; skip : overlapping windows
            <p/>
            <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowsizeskipover.png" alt=""/>
            <p/>
            When skip == maxSize : exact windows
            <p/>
            <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowsize.png" alt=""/>
            </remarks>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="size">The maximum routed items per IFlux</param>
            <param name="skip">The number of items to count before emitting a new bucket IFlux.</param>
            <returns>A windowing IFlux of sized IFlux buckets every skip count.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Window``2(Reactor.Core.IFlux{``0},Reactive.Streams.IPublisher{``1})">
            <summary>
            Split this IFlux sequence into continuous, non-overlapping windows
            where the window boundary is signalled by another IPublisher
            </summary>
            <remarks>
            <p/>
            <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowboundary.png" alt=""/>
            </remarks>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="U">The boundary value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="boundary">a IPublisher to emit any item for a split signal and complete to terminate</param>
            <returns>a windowing IFlux delimiting its sub-sequences by a given IPublisher</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Window``3(Reactor.Core.IFlux{``0},Reactive.Streams.IPublisher{``1},System.Func{``1,Reactive.Streams.IPublisher{``2}})">
            <summary>
            Split this IFlux sequence into potentially overlapping windows controlled by items of a
            start IPublisher and end IPublisher derived from the start values.
            </summary>
            <remarks>
            <p/>
            When Open signal is strictly not overlapping Close signal : dropping windows
            <p/>
            <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowopenclose.png" alt=""/>
            <p/>
            When Open signal is strictly more frequent than Close signal : overlapping windows
            <p/>
            <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowopencloseover.png" alt=""/>
            <p/>
            When Open signal is exactly coordinated with Close signal : exact windows
            <p/>
            <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowboundary.png" alt=""/>
            </remarks>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="U">The type of the sequence opening windows</typeparam>
            <typeparam name="V">The type of the sequence closing windows opened by the bucketOpening Publisher's elements</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="open">A IPublisher to emit any item for a split signal and complete to terminate</param>
            <param name="close">A function given an opening signal and returning a IPublisher that
            emits to complete the window</param>
            <returns>A windowing IFlux delimiting its sub-sequences by a given IPublisher and lasting until
            a selected IPublisher emits.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Window``1(Reactor.Core.IFlux{``0},System.TimeSpan)">
            <summary>
            Split this IFlux sequence into continuous, non-overlapping windows delimited by a given period.
            </summary>
            <remarks>
            <p/>
            <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowtimespan.png" alt=""/>
            </remarks>
            <typeparam name="T">The source value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="timespan">the duration in milliseconds to delimit IFlux windows</param>
            <returns>a windowing IFlux of timed IFlux buckets</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Window``1(Reactor.Core.IFlux{``0},System.TimeSpan,Reactor.Core.TimedScheduler)">
            <summary>
            Split this IFlux sequence into continuous, non-overlapping windows delimited by a given period.
            </summary>
            <remark>
            <p/>
            <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowtimespan.png" alt=""/>
            </remark>
            <typeparam name="T">The source value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="timespan">the duration in milliseconds to delimit IFlux windows</param>
            <param name="scheduler">The timed scheduler used for providing the timing of the window boundaries.</param>
            <returns>a windowing IFlux of timed IFlux buckets</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Window``1(Reactor.Core.IFlux{``0},System.TimeSpan,System.TimeSpan)">
            <summary>
            Split this IFlux sequence into multiple IFlux delimited by the given {@code timeshift}
            period, starting from the first item.
            Each IFlux bucket will onComplete after {@code timespan} period has elpased.
            </summary>
            <remarks>
            <p/>
            When timeshift > timespan : dropping windows
            <p/>
            <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowsizeskip.png" alt=""/>
            <p/>
            When timeshift &lt; timespan : overlapping windows
            <p/>
            <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowsizeskipover.png" alt=""/>
            <p/>
            When timeshift == timespan : exact windows
            <p/>
            <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowsize.png" alt=""/>
            </remarks>
            <typeparam name="T">The source value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="timespan">the maximum IFlux window duration in milliseconds</param>
            <param name="timeskip">the period of time in milliseconds to create new IFlux windows</param>
            <returns>a windowing IFlux of IFlux buckets delimited by an opening IPublisher and a selected closing IPublisher</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Window``1(Reactor.Core.IFlux{``0},System.TimeSpan,System.TimeSpan,Reactor.Core.TimedScheduler)">
            <summary>
            Split this IFlux sequence into multiple IFlux delimited by the given {@code timeshift}
            period, starting from the first item.
            Each IFlux bucket will onComplete after {@code timespan} period has elpased.
            </summary>
            <remarks>
            <p/>
            When timeshift > timespan : dropping windows
            <p/>
            <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowsizeskip.png" alt=""/>
            <p/>
            When timeshift &lt; timespan : overlapping windows
            <p/>
            <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowsizeskipover.png" alt=""/>
            <p/>
            When timeshift == timespan : exact windows
            <p/>
            <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowsize.png" alt=""/>
            </remarks>
            <typeparam name="T">The source value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="timespan">the maximum IFlux window duration in milliseconds</param>
            <param name="timeskip">the period of time in milliseconds to create new IFlux windows</param>
            <param name="scheduler">The timed scheduler to run the timed support operations.</param>
            <returns>a windowing IFlux of IFlux buckets delimited by an opening IPublisher and a selected closing IPublisher</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Window``1(Reactor.Core.IFlux{``0},System.Int32,System.TimeSpan)">
            <summary>
            Split this IFlux sequence into multiple IFlux delimited by the given {@code maxSize} number
            of items, starting from the first item. IFlux windows will onComplete after a given
            timespan occurs and the number of items has not be counted.
            </summary>
            <remarks>
            <p/>
            <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowsizetimeout.png" alt=""/>
            </remarks>
            <typeparam name="T">The source value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="maxSize">the maximum IFlux window items to count before onComplete</param>
            <param name="timespan">the timeout to use to onComplete a given window if size is not counted yet</param>
            <returns>a windowing IFlux of sized or timed IFlux buckets</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Window``1(Reactor.Core.IFlux{``0},System.Int32,System.TimeSpan,Reactor.Core.TimedScheduler)">
            <summary>
            Split this IFlux sequence into multiple IFlux delimited by the given {@code maxSize} number
            of items, starting from the first item. IFlux windows will onComplete after a given
            timespan occurs and the number of items has not be counted.
            </summary>
            <remarks>
            <p/>
            <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowsizetimeout.png" alt=""/>
            </remarks>
            <typeparam name="T">The source value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="maxSize">the maximum IFlux window items to count before onComplete</param>
            <param name="timespan">the timeout to use to onComplete a given window if size is not counted yet</param>
            <param name="scheduler">The timed scheduler to run the timed support operations.</param>
            <returns>a windowing IFlux of sized or timed IFlux buckets</returns>
        </member>
        <member name="M:Reactor.Core.Flux.WithLatestFrom``3(Reactor.Core.IFlux{``0},Reactive.Streams.IPublisher{``1},System.Func{``0,``1,``2})">
            <summary>
            Combines the values from the source IFlux with the latest value from the other IPublisher.
            </summary>
            <typeparam name="T1">The source value type.</typeparam>
            <typeparam name="T2">The other value type.</typeparam>
            <typeparam name="R">The result value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="other">The other IPublisher to take the latest value from.</param>
            <param name="combiner">The function receiving the current source item and the latest value from the other IPublisher
            and returns a value to be emitted.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.WithLatestFrom``4(Reactor.Core.IFlux{``0},Reactive.Streams.IPublisher{``1},Reactive.Streams.IPublisher{``2},System.Func{``0,``1,``2,``3})">
            <summary>
            Combines the values from the source IFlux with the latest value from the multiple other IPublishers.
            </summary>
            <typeparam name="T1">The source value type.</typeparam>
            <typeparam name="T2">The first other value type.</typeparam>
            <typeparam name="T3">The second other value type.</typeparam>
            <typeparam name="R">The result value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="p2">The first other IPublisher to take the latest value from.</param>
            <param name="p3">The second other IPublisher to take the latest value from.</param>
            <param name="combiner">The function receiving the current source item and the latest value from the other IPublishers
            and returns a value to be emitted.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.WithLatestFrom``5(Reactor.Core.IFlux{``0},Reactive.Streams.IPublisher{``1},Reactive.Streams.IPublisher{``2},Reactive.Streams.IPublisher{``3},System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Combines the values from the source IFlux with the latest value from the multiple other IPublishers.
            </summary>
            <typeparam name="T1">The source value type.</typeparam>
            <typeparam name="T2">The first other value type.</typeparam>
            <typeparam name="T3">The second other value type.</typeparam>
            <typeparam name="T4">The third other value type.</typeparam>
            <typeparam name="R">The result value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="p2">The first other IPublisher to take the latest value from.</param>
            <param name="p3">The second other IPublisher to take the latest value from.</param>
            <param name="p4">The third other IPublisher to take the latest value from.</param>
            <param name="combiner">The function receiving the current source item and the latest value from the other IPublishers
            and returns a value to be emitted.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.WithLatestFrom``6(Reactor.Core.IFlux{``0},Reactive.Streams.IPublisher{``1},Reactive.Streams.IPublisher{``2},Reactive.Streams.IPublisher{``3},Reactive.Streams.IPublisher{``4},System.Func{``0,``1,``2,``3,``4,``5})">
            <summary>
            Combines the values from the source IFlux with the latest value from the multiple other IPublishers.
            </summary>
            <typeparam name="T1">The source value type.</typeparam>
            <typeparam name="T2">The first other value type.</typeparam>
            <typeparam name="T3">The second other value type.</typeparam>
            <typeparam name="T4">The third other value type.</typeparam>
            <typeparam name="T5">The fourth other value type.</typeparam>
            <typeparam name="R">The result value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="p2">The first other IPublisher to take the latest value from.</param>
            <param name="p3">The second other IPublisher to take the latest value from.</param>
            <param name="p4">The third other IPublisher to take the latest value from.</param>
            <param name="p5">The fourth other IPublisher to take the latest value from.</param>
            <param name="combiner">The function receiving the current source item and the latest value from the other IPublishers
            and returns a value to be emitted.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.WithLatestFrom``7(Reactor.Core.IFlux{``0},Reactive.Streams.IPublisher{``1},Reactive.Streams.IPublisher{``2},Reactive.Streams.IPublisher{``3},Reactive.Streams.IPublisher{``4},Reactive.Streams.IPublisher{``5},System.Func{``0,``1,``2,``3,``4,``5,``6})">
            <summary>
            Combines the values from the source IFlux with the latest value from the multiple other IPublishers.
            </summary>
            <typeparam name="T1">The source value type.</typeparam>
            <typeparam name="T2">The first other value type.</typeparam>
            <typeparam name="T3">The second other value type.</typeparam>
            <typeparam name="T4">The third other value type.</typeparam>
            <typeparam name="T5">The fourth other value type.</typeparam>
            <typeparam name="T6">The fifth other value type.</typeparam>
            <typeparam name="R">The result value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="p2">The first other IPublisher to take the latest value from.</param>
            <param name="p3">The second other IPublisher to take the latest value from.</param>
            <param name="p4">The third other IPublisher to take the latest value from.</param>
            <param name="p5">The fourth other IPublisher to take the latest value from.</param>
            <param name="p6">The fifth other IPublisher to take the latest value from.</param>
            <param name="combiner">The function receiving the current source item and the latest value from the other IPublishers
            and returns a value to be emitted.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.WithLatestFrom``2(Reactor.Core.IFlux{``0},System.Func{``0[],``1},Reactive.Streams.IPublisher{``0}[])">
            <summary>
            Combines the values from the source IFlux with the latest value from the multiple other IPublishers.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <typeparam name="R">The result value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="others">The other IPublishers to take the latest value from.</param>
            <param name="combiner">The function receiving the current source item and the latest value from the other IPublishers
            and returns a value to be emitted.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.ZipWith``2(Reactor.Core.IFlux{``0},Reactive.Streams.IPublisher{``0},System.Func{``0,``0,``1})">
            <summary>
            Combines rows of elements from the source IFlux and the other IPublisher and emits
            the value by the function.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="R">The result type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="other">The other IPublisher</param>
            <param name="zipper">The function that receives the two next values from the source and other and returns a value in exchange
            to be emitted.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.ZipWith``2(Reactor.Core.IFlux{``0},Reactive.Streams.IPublisher{``0},System.Func{``0,``0,``1},System.Int32)">
            <summary>
            Combines rows of elements from the source IFlux and the other IPublisher and emits
            the value by the function.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="R">The result type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="other">The other IPublisher</param>
            <param name="zipper">The function that receives the two next values from the source and other and returns a value in exchange
            to be emitted.</param>
            <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
            unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.ZipWith``3(Reactor.Core.IFlux{``0},Reactive.Streams.IPublisher{``1},System.Func{``0,``1,``2})">
            <summary>
            Combines rows of elements from the source IFlux and the other IPublisher and emits
            the value by the function.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="U">The other value type.</typeparam>
            <typeparam name="R">The result type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="other">The other IPublisher</param>
            <param name="zipper">The function that receives the two next values from the source and other and returns a value in exchange
            to be emitted.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.ZipWith``3(Reactor.Core.IFlux{``0},Reactive.Streams.IPublisher{``1},System.Func{``0,``1,``2},System.Int32)">
            <summary>
            Combines rows of elements from the source IFlux and the other IPublisher and emits
            the value by the function.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="U">The other value type.</typeparam>
            <typeparam name="R">The result type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="other">The other IPublisher</param>
            <param name="zipper">The function that receives the two next values from the source and other and returns a value in exchange
            to be emitted.</param>
            <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
            unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.ZipWith``3(Reactor.Core.IFlux{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})">
            <summary>
            Combines the elements of the source IFlux with the next value from the IEnumerable sequence through
            a function.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="U">The IEnumerable's value type.</typeparam>
            <typeparam name="R">The result type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="other">The other IEnumerable instance.</param>
            <param name="zipper">The function that receives the two next values from the source and other and returns a value in exchange
            to be emitted.</param>
            <returns>The new IFlux instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.BlockFirst``1(Reactor.Core.IFlux{``0})">
            <summary>
            Subscribe to the source and block until it produces a value or
            signals an Exception. An empty source will throw an IndexOutOfRangeException.
            </summary>
            <typeparam name="T">The value type</typeparam>
            <param name="source">The source</param>
            <returns>The value produced</returns>
            <exception cref="T:System.IndexOutOfRangeException">If the source is empty.</exception>
        </member>
        <member name="M:Reactor.Core.Flux.BlockFirst``1(Reactor.Core.IFlux{``0},System.TimeSpan)">
            <summary>
            Subscribe to the source and block until it produces a value or
            signals an Exception. An empty source will throw an IndexOutOfRangeException.
            </summary>
            <typeparam name="T">The value type</typeparam>
            <param name="source">The source</param>
            <param name="timeout">The maximum amount of time to wait for the value.</param>
            <returns>The value produced</returns>
            <exception cref="T:System.IndexOutOfRangeException">If the source is empty.</exception>
            <exception cref="T:System.TimeoutException">If the source didn't produce any value within the given timeout.</exception>
        </member>
        <member name="M:Reactor.Core.Flux.BlockLast``1(Reactor.Core.IFlux{``0})">
            <summary>
            Subscribe to the source and block until it completes and returns the last value produces a value or
            signals an Exception. An empty source will throw an IndexOutOfRangeException.
            </summary>
            <typeparam name="T">The value type</typeparam>
            <param name="source">The source</param>
            <returns>The value produced</returns>
            <exception cref="T:System.IndexOutOfRangeException">If the source is empty.</exception>
        </member>
        <member name="M:Reactor.Core.Flux.BlockLast``1(Reactor.Core.IFlux{``0},System.TimeSpan)">
            <summary>
            Subscribe to the source and block until it completes and returns the last value or
            signals an Exception. An empty source will throw an IndexOutOfRangeException.
            </summary>
            <typeparam name="T">The value type</typeparam>
            <param name="source">The source</param>
            <param name="timeout">The maximum amount of time to wait for the value.</param>
            <returns>The value produced</returns>
            <exception cref="T:System.IndexOutOfRangeException">If the source is empty.</exception>
            <exception cref="T:System.TimeoutException">If the source didn't produce any value within the given timeout.</exception>
        </member>
        <member name="M:Reactor.Core.Flux.Subscribe``1(Reactor.Core.IFlux{``0})">
            <summary>
            Subscribes to the IPublisher and ignores all of its signals.
            </summary>
            <typeparam name="T">The value type</typeparam>
            <param name="source">The source IPublisher</param>
            <returns>The IDisposable that allows cancelling the subscription.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Subscribe``1(Reactor.Core.IFlux{``0},System.Action{``0})">
            <summary>
            Subscribes to the IPublisher and consumes only its OnNext signals.
            </summary>
            <typeparam name="T">The value type</typeparam>
            <param name="source">The source IPublisher</param>
            <param name="onNext">The callback for the OnNext signals</param>
            <returns>The IDisposable that allows cancelling the subscription.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Subscribe``1(Reactor.Core.IFlux{``0},System.Action{``0},System.Action{System.Exception})">
            <summary>
            Subscribes to the IPublisher and consumes only its OnNext signals.
            </summary>
            <remarks>
            If the <paramref name="onNext"/> callback crashes, the error is routed
            to <paramref name="onError"/> callback.
            If the <paramref name="onError"/> callback crashes, the error is routed to the
            global error hanlder in <see cref="M:Reactor.Core.ExceptionHelper.OnErrorDropped(System.Exception)"/>.
            </remarks>
            <typeparam name="T">The value type</typeparam>
            <param name="source">The source IPublisher</param>
            <param name="onNext">The callback for the OnNext signals</param>
            <param name="onError">The callback for the OnError signals</param>
            <returns>The IDisposable that allows cancelling the subscription.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Subscribe``1(Reactor.Core.IFlux{``0},System.Action{``0},System.Action{System.Exception},System.Action)">
            <summary>
            Subscribes to the IPublisher and consumes only its OnNext signals.
            </summary>
            <remarks>
            If the <paramref name="onNext"/> callback crashes, the error is routed
            to <paramref name="onError"/> callback.
            If the <paramref name="onError"/> or <paramref name="onComplete"/> callbackcrashes, 
            the error is routed to the
            global error hanlder in <see cref="M:Reactor.Core.ExceptionHelper.OnErrorDropped(System.Exception)"/>.
            </remarks>
            <typeparam name="T">The value type</typeparam>
            <param name="source">The source IPublisher</param>
            <param name="onNext">The callback for the OnNext signals.</param>
            <param name="onError">The callback for the OnError signal.</param>
            <param name="onComplete">The callback for the OnComplete signal.</param>
            <returns>The IDisposable that allows cancelling the subscription.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.SubscribeWith``2(Reactor.Core.IFlux{``0},``1)">
            <summary>
            Subscribes with the given subscriber subclass to the source and returns that subscriber instance.
            </summary>
            <typeparam name="T">The source value type.</typeparam>
            <typeparam name="E">The ISubscriber type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="subscriber">The subscriber to subscribe with and to be returned.</param>
            <returns>The <paramref name="subscriber"/>.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.ToEnumerable``1(Reactor.Core.IFlux{``0})">
            <summary>
            Converts the source into a blocking IEnumerable sequence.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <returns>The new IEnumerable instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.ToEnumerable``1(Reactor.Core.IFlux{``0},System.Int32)">
            <summary>
            Converts the source into a blocking IEnumerable sequence.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux.</param>
            <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
            unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
            <returns>The new IEnumerable instance.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.FirstTask``1(Reactor.Core.IFlux{``0})">
            <summary>
            Returns a Task that awaits the first item from the IFlux or
            signals an IndexOutOfRangeException if the IFlux is empty.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux</param>
            <returns>The task.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.FirstTask``1(Reactor.Core.IFlux{``0},System.Threading.CancellationToken)">
            <summary>
            Returns a Task that awaits the first item from the IFlux or
            signals an IndexOutOfRangeException if the IFlux is empty.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux</param>
            <param name="ct">The cancellation token.</param>
            <returns>The task.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.LastTask``1(Reactor.Core.IFlux{``0})">
            <summary>
            Returns a Task that awaits the last item from the IFlux or
            signals an IndexOutOfRangeException if the IFlux is empty.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux</param>
            <returns>The task.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.LastTask``1(Reactor.Core.IFlux{``0},System.Threading.CancellationToken)">
            <summary>
            Returns a Task that awaits the last item from the IFlux or
            signals an IndexOutOfRangeException if the IFlux is empty.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux</param>
            <param name="ct">The cancellation token.</param>
            <returns>The task.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.WhenCompleteTask``1(Reactor.Core.IFlux{``0})">
            <summary>
            Return a Task that waits for the IMono source to complete.
            </summary>
            <param name="source">The source IMono</param>
            <returns>The task.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.WhenCompleteTask``1(Reactor.Core.IFlux{``0},System.Threading.CancellationToken)">
            <summary>
            Return a Task that waits for the IMono source to complete
            and support the cancellation of such wait.
            </summary>
            <param name="source">The source IMono</param>
            <param name="ct">The cancellation token.</param>
            <returns>The task.</returns>
        </member>
        <member name="M:Reactor.Core.Flux.Test``1(Reactor.Core.IFlux{``0},System.Int64,System.Int32,System.Boolean)">
            <summary>
            Creates a TestSubscriber with the given initial settings and returns it.
            </summary>
            <typeparam name="T">The value type received.</typeparam>
            <param name="source">The source IFlux</param>
            <param name="initialRequest">The optional initial request amount.</param>
            <param name="fusionMode">The optional fusion mode if supported by the source.</param>
            <param name="cancelled">Optionally start out as cancelled.</param>
            <returns></returns>
        </member>
        <member name="M:Reactor.Core.Flux.OnNext``2(Reactive.Streams.IProcessor{``0,``1},``0,``0,``0[])">
            <summary>
            Convenience method to signal the given values to the IProcessor.
            </summary>
            <typeparam name="T">The input value type.</typeparam>
            <typeparam name="U">The output value type</typeparam>
            <param name="processor">The target processor instance.</param>
            <param name="t1">The first value to signal.</param>
            <param name="t2">The second value to signal.</param>
            <param name="values">The rest of the values to signal.</param>
        </member>
        <member name="T:Reactor.Core.IOrderedItem`1">
            <summary>
            Base interface for indexed one element container.
            </summary>
            <typeparam name="T">The contained value type</typeparam>
        </member>
        <member name="P:Reactor.Core.IOrderedItem`1.Index">
            <summary>
            The index of the contained element.
            </summary>
        </member>
        <member name="P:Reactor.Core.IOrderedItem`1.Value">
            <summary>
            The contained element.
            </summary>
        </member>
        <member name="M:Reactor.Core.IOrderedItem`1.Replace``1(``0)">
            <summary>
            Returns an IOrderedItem with the same index but different value content.
            </summary>
            <typeparam name="R">The result value type.</typeparam>
            <param name="value">The replacement value.</param>
            <returns>The IOrderedItem with the same index as this and the given value as content.</returns>
        </member>
        <member name="T:Reactor.Core.ParallelFlux">
            <summary>
            Base class for parallel publishers that take an array of Subscribers.
            and allow running sequences in parallel.
            </summary>
            <remarks>
            <p>Use {@code fork()} to start processing a regular Publisher in 'rails'.</p>
            <p>Use {@code runOn()} to introduce where each 'rail' shoud run on thread-vise.</p>
            <p>Use {@code join()} to merge the sources back into a single Publisher.</p>
            </remarks>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.Parallel``1(Reactor.Core.IFlux{``0},System.Boolean)">
            <summary>
            Take a Publisher and prepare to consume it on multiple 'rails' (number 
            of CPUs) in a round-robin fashion.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux instance.</param>
            <param name="ordered">if converted back to a IFlux, should the end result be ordered?</param>
            <returns>the new IParallelPublisher instance</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.Parallel``1(Reactor.Core.IFlux{``0},System.Int32,System.Boolean)">
            <summary>
            ake a Publisher and prepare to consume it on parallallism number of 'rails', 
            possibly ordered and round-robin fashion.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux instance.</param>
            <param name="parallelism">the number of parallel rails</param>
            <param name="ordered">if converted back to a IFlux, should the end result be ordered?</param>
            <returns>the new IParallelPublisher instance</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.Parallel``1(Reactor.Core.IFlux{``0},System.Int32,System.Int32,System.Boolean)">
            <summary>
            Take a Publisher and prepare to consume it on parallallism number of 'rails',
            possibly ordered and round-robin fashion and use custom prefetch amount and queue
            for dealing with the source Publisher's values.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IFlux instance.</param>
            <param name="parallelism">the number of parallel rails</param>
            <param name="prefetch">the number of values to prefetch from the source</param>
            <param name="ordered">if converted back to a IFlux, should the end result be ordered?</param>
            <returns>the new IParallelPublisher instance</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.Map``2(Reactor.Core.IParallelFlux{``0},System.Func{``0,``1})">
            <summary>
            aps the source values on each 'rail' to another value.
            </summary>
            <remarks>
            Note that the same predicate may be called from multiple threads concurrently.
            </remarks>
            <typeparam name="T">The value type.</typeparam>
            <typeparam name="R">The result value type.</typeparam>
            <param name="source">The source IParallelPublisher instance.</param>
            <param name="mapper">the mapper function turning Ts into Us</param>
            <returns>the new IParallelPublisher instance</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.Filter``1(Reactor.Core.IParallelFlux{``0},System.Func{``0,System.Boolean})">
            <summary>
            Filters the source values on each 'rail'.
            </summary>
            <remarks>
            Note that the same predicate may be called from multiple threads concurrently.
            </remarks>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IParallelPublisher instance.</param>
            <param name="predicate">the function returning true to keep a value or false to drop a value</param>
            <returns>the new IParallelPublisher instance</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.RunOn``1(Reactor.Core.IParallelFlux{``0},Reactor.Core.Scheduler)">
            <summary>
            Specifies where each 'rail' will observe its incoming values with
            no work-stealing and default prefetch amount.
            </summary>
            <remarks>
            This operator uses the default prefetch size returned by {@code Px.bufferSize()}.
            <p/>
            The operator will call {@code Scheduler.createWorker()} as many
            times as this ParallelPublisher's parallelism level is.
            <p/>
            No assumptions are made about the Scheduler's parallelism level,
            if the Scheduler's parallelism level is lwer than the ParallelPublisher's,
            some rails may end up on the same thread/worker.
            <p/>
            This operator doesn't require the Scheduler to be trampolining as it
            does its own built-in trampolining logic.
            </remarks>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IParallelPublisher instance.</param>
            <param name="scheduler">The scheduler whose workers to use.</param>
            <returns>the new IParallelPublisher instance</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.RunOn``1(Reactor.Core.IParallelFlux{``0},Reactor.Core.Scheduler,System.Int32)">
            <summary>
            Specifies where each 'rail' will observe its incoming values with
            no work-stealing and a given prefetch amount.
            </summary>
            <remarks>
            This operator uses the default prefetch size returned by {@code Px.bufferSize()}.
            <p/>
            The operator will call {@code Scheduler.createWorker()} as many
            times as this ParallelPublisher's parallelism level is.
            <p/>
            No assumptions are made about the Scheduler's parallelism level,
            if the Scheduler's parallelism level is lwer than the ParallelPublisher's,
            some rails may end up on the same thread/worker.
            <p/>
            This operator doesn't require the Scheduler to be trampolining as it
            does its own built-in trampolining logic.
            </remarks>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IParallelPublisher instance.</param>
            <param name="scheduler">The scheduler whose workers to use.</param>
            <param name="prefetch">the number of values to request on each 'rail' from the source</param>
            <returns>the new IParallelPublisher instance</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.Reduce``1(Reactor.Core.IParallelFlux{``0},System.Func{``0,``0,``0})">
            <summary>
            Reduces all values within a 'rail' and across 'rails' with a reducer function into a single
            sequential value.
            </summary>
            <remarks>
            Note that the same reducer function may be called from multiple threads concurrently.
            </remarks>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IParallelPublisher instance.</param>
            <param name="reducer">the function to reduce two values into one</param>
            <returns>the new IFlux instance emitting the reduced value or empty if the IParallelPublisher was empty</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.Reduce``2(Reactor.Core.IParallelFlux{``0},System.Func{``1},System.Func{``1,``0,``1})">
            <summary>
            Reduces all values within a 'rail' to a single value (with a possibly different type) via
            a reducer function that is initialized on each rail from an initialSupplier value.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <typeparam name="R">The reduced output type</typeparam>
            <param name="source">The source IParallelPublisher instance.</param>
            <param name="initialValue">the supplier for the initial value</param>
            <param name="reducer">the function to reduce a previous output of reduce (or the initial value supplied)
            with a current source value.</param>
            <returns>the new IParallelPublisher instance</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.Sequential``1(Reactor.Core.IParallelFlux{``0})">
            <summary>
            Merges the values from each 'rail' in a round-robin or same-order fashion and
            exposes it as a regular IFLux sequence, running with a default prefetch value
            for the rails.
            </summary>
            <remarks>
            This operator uses the default prefetch size returned by <see cref="P:Reactor.Core.Flux.BufferSize"/>.
            </remarks>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IParallelPublisher instance.</param>
            <returns>The new IFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.Sequential``1(Reactor.Core.IParallelFlux{``0},System.Int32)">
            <summary>
            Merges the values from each 'rail' in a round-robin or same-order fashion and
            exposes it as a regular Publisher sequence, running with a give prefetch value
            for the rails.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IParallelPublisher instance.</param>
            <param name="prefetch">the prefetch amount to use for each rail</param>
            <returns>The new IFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.Sorted``1(Reactor.Core.IParallelFlux{``0},System.Int32)">
            <summary>
            Sorts the 'rails' of this ParallelPublisher and returns a Publisher that sequentially
            picks the smallest next value from the rails based on the type-default comparer.
            </summary>
            <remarks>
            This operator requires a finite source IParallelPublisher.
            </remarks>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IParallelPublisher instance.</param>
            <param name="capacityHint">the expected number of total elements</param>
            <returns>The new IFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.Sorted``1(Reactor.Core.IParallelFlux{``0},System.Collections.Generic.IComparer{``0},System.Int32)">
            <summary>
            Sorts the 'rails' of this ParallelPublisher and returns a Publisher that sequentially
            picks the smallest next value from the rails.
            </summary>
            <remarks>
            This operator requires a finite source IParallelPublisher.
            </remarks>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IParallelPublisher instance.</param>
            <param name="comparer">the IComparer to use</param>
            <param name="capacityHint">the expected number of total elements</param>
            <returns>The new IFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.ToSortedList``1(Reactor.Core.IParallelFlux{``0},System.Collections.Generic.IComparer{``0},System.Int32)">
            <summary>
            Sorts the 'rails' according to the comparator and returns a full sorted list as a Publisher.
            </summary>
            <remarks>
            This operator requires a finite source IParallelPublisher.
            </remarks>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IParallelPublisher instance.</param>
            <param name="comparer">the IComparer to use</param>
            <param name="capacityHint">the expected number of total elements</param>
            <returns>The new IFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.DoAfterTerminate``1(Reactor.Core.IParallelFlux{``0},System.Action)">
            <summary>
            Call the specified action after each 'rail' terminates.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IParallelPublisher instance.</param>
            <param name="onAfterTerminate">The action to call</param>
            <returns>The new IParallelFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.DoAfterNext``1(Reactor.Core.IParallelFlux{``0},System.Action{``0})">
            <summary>
            Call the specified consumer with the current element passing through any 'rail'
            after it has been delivered to downstream within the rail.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IParallelPublisher instance.</param>
            <param name="onAfterNext">the action to call</param>
            <returns>The new IParallelFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.DoOnCancel``1(Reactor.Core.IParallelFlux{``0},System.Action)">
            <summary>
            Run the specified runnable when a 'rail' receives a cancellation.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IParallelPublisher instance.</param>
            <param name="onCancel">The action to call</param>
            <returns>The new IParallelFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.DoOnComplete``1(Reactor.Core.IParallelFlux{``0},System.Action)">
            <summary>
            Run the specified runnable when a 'rail' completes.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IParallelPublisher instance.</param>
            <param name="onComplete">The action to call</param>
            <returns>The new IParallelFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.DoOnError``1(Reactor.Core.IParallelFlux{``0},System.Action{System.Exception})">
            <summary>
            Call the specified consumer with the exception passing through any 'rail'.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IParallelPublisher instance.</param>
            <param name="onError">The action to call</param>
            <returns>The new IParallelFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.DoOnError``2(Reactor.Core.IParallelFlux{``0},System.Action{``1})">
            <summary>
            Call the specified consumer with a specific exception class passing through any 'rail'.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <typeparam name="E">The exception type</typeparam>
            <param name="source">The source IParallelPublisher instance.</param>
            <param name="onError">The action to call</param>
            <returns>The new IParallelFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.DoOnError``1(Reactor.Core.IParallelFlux{``0},System.Func{System.Exception,System.Boolean},System.Action{System.Exception})">
            <summary>
            Call the specified predicate with a errors passing through any 'rail' 
            and if it returns true, call the action with it.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IParallelPublisher instance.</param>
            <param name="predicate">The predicate to call with any errors passing through.</param>
            <param name="onError">The action to call</param>
            <returns>The new IParallelFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.DoOnNext``1(Reactor.Core.IParallelFlux{``0},System.Action{``0})">
            <summary>
            Call the specified consumer with the current element passing through any 'rail'.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IParallelPublisher instance.</param>
            <param name="onNext">The action to call</param>
            <returns>The new IParallelFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.DoOnRequest``1(Reactor.Core.IParallelFlux{``0},System.Action{System.Int64})">
            <summary>
            Call the specified consumer with the request amount if any rail receives a request.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IParallelPublisher instance.</param>
            <param name="onRequest">the action to call</param>
            <returns>The new IParallelFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.DoOnSubscribe``1(Reactor.Core.IParallelFlux{``0},System.Action{Reactive.Streams.ISubscription})">
            <summary>
            Call the specified callback when a 'rail' receives a Subscription from its upstream.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IParallelPublisher instance.</param>
            <param name="onSubscribe">The action to call</param>
            <returns>The new IParallelFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.DoOnTerminate``1(Reactor.Core.IParallelFlux{``0},System.Action)">
            <summary>
            Call the specified callback before the terminal event is delivered on each 'rail'.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IParallelPublisher instance.</param>
            <param name="onTerminate">The action to call</param>
            <returns>The new IParallelFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.Collect``2(Reactor.Core.IParallelFlux{``0},System.Func{``1},System.Action{``1,``0})">
            <summary>
            Collect the elements in each rail into a collection supplied via a collectionSupplier
            and collected into with a collector action, emitting the collection at the end.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <typeparam name="C">the collection type</typeparam>
            <param name="source">The source IParallelPublisher instance.</param>
            <param name="initialCollection">the supplier of the collection in each rail</param>
            <param name="collector">the collector, taking the per-rali collection and the current item</param>
            <returns>The new IParallelFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.Groups``1(Reactor.Core.IParallelFlux{``0})">
            <summary>
            Exposes the 'rails' as individual GroupedPublisher instances, keyed by the rail index (zero based).
            </summary>
            <remarks>
            Each group can be consumed only once; requests and cancellation compose through. Note
            that cancelling only one rail may result in undefined behavior.
            </remarks>
            <typeparam name="T">The value type.</typeparam>
            <param name="source">The source IParallelPublisher instance.</param>
            <returns>The new IFlux instance with the inner IGroupedFlux instances.</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.From``1(Reactive.Streams.IPublisher{``0}[])">
            <summary>
            Wraps multiple Publishers into a ParallelPublisher which runs them
            in parallel and unordered.
            </summary>
            <typeparam name="T">the value type</typeparam>
            <param name="sources">the params array of IPublishers</param>
            <returns>The new IParallelFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.Ordered``1(Reactor.Core.IParallelFlux{``0},System.Boolean)">
            <summary>
            Turns this Parallel sequence into an ordered sequence via local indexing,
            if not already ordered.
            </summary>
            <typeparam name="T">the value type</typeparam>
            <param name="source">The source IParallelPublisher instance.</param>
            <param name="global">hould the indexing local (per rail) or globar FIFO?</param>
            <returns>The new IParallelFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.Unordered``1(Reactor.Core.IParallelFlux{``0})">
            <summary>
            Removes any ordering information from this Parallel sequence,
            if not already unordered.
            </summary>
            <typeparam name="T">the value type</typeparam>
            <param name="source">The source IParallelPublisher instance.</param>
            <returns>The new IParallelFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.As``2(Reactor.Core.IParallelFlux{``0},System.Func{Reactor.Core.IParallelFlux{``0},``1})">
            <summary>
            Perform a fluent transformation to a value via a converter function which
            receives this ParallelPublisher.
            </summary>
            <typeparam name="T">the value type</typeparam>
            <typeparam name="R">The result type</typeparam>
            <param name="source">The source IParallelPublisher instance.</param>
            <param name="converter">the converter function from IParallelPublisher to some type</param>
            <returns>the value returned by the converter function</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.FlatMap``2(Reactor.Core.IParallelFlux{``0},System.Func{``0,Reactive.Streams.IPublisher{``1}},System.Boolean)">
            <summary>
            Generates and flattens IPublishers on each 'rail'.
            </summary>
            <remarks>
            Errors are not delayed and uses unbounded concurrency along with default inner prefetch.
            </remarks>
            <typeparam name="T">the value type</typeparam>
            <typeparam name="R">The result type</typeparam>
            <param name="source">The source IParallelPublisher instance.</param>
            <param name="mapper">the function to map each rail's value into a IPublisher</param>
            <param name="delayErrors">should the errors from the main and the inner sources delayed till everybody terminates?</param>
            <returns>The new IParallelFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.FlatMap``2(Reactor.Core.IParallelFlux{``0},System.Func{``0,Reactive.Streams.IPublisher{``1}},System.Int32,System.Boolean)">
            <summary>
            Generates and flattens Publishers on each 'rail', optionally delaying errors 
            and having a total number of simultaneous subscriptions to the inner IPublishers.
            </summary>
            <typeparam name="T">the value type</typeparam>
            <typeparam name="R">The result type</typeparam>
            <param name="source">The source IParallelPublisher instance.</param>
            <param name="mapper">the function to map each rail's value into a IPublisher</param>
            <param name="maxConcurrency">the maximum number of simultaneous subscriptions to the generated inner IPublishers</param>
            <param name="delayErrors">should the errors from the main and the inner sources delayed till everybody terminates?</param>
            <returns>The new IParallelFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.FlatMap``2(Reactor.Core.IParallelFlux{``0},System.Func{``0,Reactive.Streams.IPublisher{``1}},System.Int32,System.Int32,System.Boolean)">
            <summary>
            Generates and flattens Publishers on each 'rail', optionally delaying errors, 
            having a total number of simultaneous subscriptions to the inner Publishers
            and using the given prefetch amount for the inner Publishers.
            </summary>
            <typeparam name="T">the value type</typeparam>
            <typeparam name="R">The result type</typeparam>
            <param name="source">The source IParallelPublisher instance.</param>
            <param name="mapper">the function to map each rail's value into a IPublisher</param>
            <param name="maxConcurrency">the maximum number of simultaneous subscriptions to the generated inner IPublishers</param>
            <param name="prefetch">the number of items to prefetch from each inner IPublisher</param>
            <param name="delayErrors">should the errors from the main and the inner sources delayed till everybody terminates?</param>
            <returns>The new IParallelFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.ConcatMap``2(Reactor.Core.IParallelFlux{``0},System.Func{``0,Reactive.Streams.IPublisher{``1}},Reactor.Core.ConcatErrorMode)">
            <summary>
            Generates and concatenates Publishers on each 'rail', signalling errors immediately 
            and using the given prefetch amount for generating Publishers upfront.
            </summary>
            <typeparam name="T">the value type</typeparam>
            <typeparam name="R">The result type</typeparam>
            <param name="source">The source IParallelPublisher instance.</param>
            <param name="mapper">the function to map each rail's value into a IPublisher</param>
            <param name="errorMode">the error handling, i.e., when to report errors from the main
            source and the inner Publishers (immediate, boundary, end)</param>
            <returns>The new IParallelFlux instance</returns>
        </member>
        <member name="M:Reactor.Core.ParallelFlux.ConcatMap``2(Reactor.Core.IParallelFlux{``0},System.Func{``0,Reactive.Streams.IPublisher{``1}},System.Int32,Reactor.Core.ConcatErrorMode)">
            <summary>
            Generates and concatenates Publishers on each 'rail', optionally delaying errors
            and using the given prefetch amount for generating IPublishers upfront.
            </summary>
            <typeparam name="T">the value type</typeparam>
            <typeparam name="R">The result type</typeparam>
            <param name="source">The source IParallelPublisher instance.</param>
            <param name="mapper">the function to map each rail's value into a IPublisher</param>
            <param name="prefetch">the number of items to prefetch from each inner IPublisher</param>
            <param name="errorMode">the error handling, i.e., when to report errors from the main
            source and the inner Publishers (immediate, boundary, end)</param>
            <returns>The new IParallelFlux instance</returns>
        </member>
        <member name="T:Reactor.Core.publisher.PublisherOnBackpressureLatest`1.Node">
            <summary>
            Class to host the latest value (needed for Interlocked.Exchange).
            </summary>
        </member>
        <member name="T:Reactor.Core.publisher.PublisherAsObservable`1">
            <summary>
            Wraps an IPublisher and exposes it as an IObservable.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Reactor.Core.publisher.PublisherBufferBoundary`2.BufferWorkType.VALUE">
            <summary>
            Add a value to the current buffer.
            </summary>
        </member>
        <member name="F:Reactor.Core.publisher.PublisherBufferBoundary`2.BufferWorkType.COMPLETE">
            <summary>
            Complete the entire buffering operation.
            </summary>
        </member>
        <member name="F:Reactor.Core.publisher.PublisherBufferBoundary`2.BufferWorkType.BOUNDARY">
            <summary>
            Start a new buffer.
            </summary>
        </member>
        <member name="F:Reactor.Core.publisher.PublisherBufferOpenClose`3.BufferWorkType.VALUE">
            <summary>
            Add a value to the active buffers.
            </summary>
        </member>
        <member name="F:Reactor.Core.publisher.PublisherBufferOpenClose`3.BufferWorkType.COMPLETE">
            <summary>
            Complete all buffers.
            </summary>
        </member>
        <member name="F:Reactor.Core.publisher.PublisherBufferOpenClose`3.BufferWorkType.OPEN">
            <summary>
            Open a new buffer.
            </summary>
        </member>
        <member name="F:Reactor.Core.publisher.PublisherBufferOpenClose`3.BufferWorkType.CLOSE">
            <summary>
            Close a specific buffer.
            </summary>
        </member>
        <member name="M:Reactor.Core.publisher.PublisherCallableXMap`2.CallableXMap(Reactive.Streams.IPublisher{`0},Reactive.Streams.ISubscriber{`1},System.Func{`0,Reactive.Streams.IPublisher{`1}})">
            <summary>
            Applies shortcuts if the source is the empty instance or an ICallable.
            </summary>
            <param name="source">The source IPublisher.</param>
            <param name="s">The ISubscriber</param>
            <param name="mapper">The function that takes a source value and maps it into an IPublisher.</param>
            <returns>True if the optimizations were applied.</returns>
        </member>
        <member name="F:Reactor.Core.publisher.PublisherConcatMap`2.ConcatBaseSubscriber.wip">
            <summary>
            Work-in-progress indicator for inner subscriptions.
            </summary>
        </member>
        <member name="F:Reactor.Core.publisher.PublisherConcatMap`2.ConcatImmediateSubscriber.serializer">
            <summary>
            Work-in-progress indicator for the half-serializer logic.
            </summary>
        </member>
        <member name="F:Reactor.Core.publisher.PublisherConcatMap`2.ConcatBaseConditionalSubscriber.wip">
            <summary>
            Work-in-progress indicator for inner subscriptions.
            </summary>
        </member>
        <member name="F:Reactor.Core.publisher.PublisherConcatMap`2.ConcatImmediateConditionalSubscriber.serializer">
            <summary>
            Work-in-progress indicator for the half-serializer logic.
            </summary>
        </member>
        <member name="T:Reactor.Core.publisher.PublisherJust`1">
            <summary>
            A constant scalar source.
            </summary>
            <remarks>
            It is based on IMono to facilitate easy reuse for Flux and Mono extension methods.
            </remarks>
            <typeparam name="T">The value type</typeparam>
        </member>
        <member name="F:Reactor.Core.publisher.PublisherPublishOn`1.BasePublishOnSubscriber.emitted">
            <summary>
            Number of items successfully emitted to downstream -
            paired with the requested amount.
            </summary>
        </member>
        <member name="F:Reactor.Core.publisher.PublisherPublishOn`1.BasePublishOnSubscriber.polled">
            <summary>
            Number of items requested from upstream - reset to zero
            when the <see cref="F:Reactor.Core.publisher.PublisherPublishOn`1.BasePublishOnSubscriber.limit"/> is reached. 
            </summary>
        </member>
        <member name="M:Reactor.Core.publisher.PublisherSubscribeOn`1.TrySingleSchedule(Reactive.Streams.IPublisher{`0},Reactive.Streams.ISubscriber{`0},Reactor.Core.Scheduler)">
            <summary>
            Checks if the source is ICallable and if so, subscribes with a custom
            Subscription that schedules the first request on the scheduler directly
            and reads the Callable.Value on that thread.
            </summary>
            <param name="source">The source IPublisher to check</param>
            <param name="s">The target subscriber.</param>
            <param name="scheduler">The Scheduler to use.</param>
            <returns></returns>
        </member>
        <member name="F:Reactor.Core.publisher.PublisherSwitchMap`2.TERMINATED">
            <summary>
            The terminated instance
            </summary>
        </member>
        <member name="T:Reactor.Core.ExceptionHelper">
            <summary>
            Hosts callbacks to override default behaviors at runtime.
            </summary>
        </member>
        <member name="M:Reactor.Core.ExceptionHelper.IsLockdown">
            <summary>
            Check if the plugins are in lockdown.
            </summary>
            <returns>True if the plugins are locked down and can't be changed anymore.</returns>
        </member>
        <member name="M:Reactor.Core.ExceptionHelper.Lockdown">
            <summary>
            When called, the callbacks can no longer be changed.
            </summary>
        </member>
        <member name="P:Reactor.Core.ExceptionHelper.OnErrorHandler">
            <summary>
            Handler for undeliverable Exceptions (which can not be sent via OnError due to
            <see cref="T:Reactive.Streams.ISubscriber`1">ISubscriber</see> lifecycle requirements).
            </summary>
        </member>
        <member name="M:Reactor.Core.ExceptionHelper.OnErrorDropped(System.Exception)">
            <summary>
            Signal to a global handler if an Exception can't be delivered through the
            regular <see cref="M:Reactive.Streams.ISubscriber`1.OnError(System.Exception)"/> method.
            </summary>
            <param name="e">The Exception that occurred.</param>
        </member>
        <member name="M:Reactor.Core.ExceptionHelper.ThrowIfFatal(System.Exception)">
            <summary>
            Rethrows an exception if it is considered fatal.
            </summary>
            <param name="ex">The exception to rethrow</param>
        </member>
        <member name="M:Reactor.Core.ExceptionHelper.ReportError``1(System.Exception,Reactive.Streams.ISubscriber{``0},System.Boolean@)">
            <summary>
            Singals the error to the subscriber and sets a done flag if the
            Exception is non fatal.
            </summary>
            <typeparam name="T">The value type of the ISubscriber.</typeparam>
            <param name="ex">The exception to signal.</param>
            <param name="subscriber">The target ISubscriber</param>
            <param name="done">the flag to check if false and set it to true</param>
        </member>
        <member name="M:Reactor.Core.ExceptionHelper.ReportError``1(System.Exception,Reactive.Streams.ISubscriber{``0},System.Boolean@,Reactive.Streams.ISubscription)">
            <summary>
            Cancels the ISubscription, singals the error to the subscriber and sets a done flag if the
            Exception is non fatal.
            </summary>
            <typeparam name="T">The value type of the ISubscriber.</typeparam>
            <param name="ex">The exception to signal.</param>
            <param name="subscriber">The target ISubscriber</param>
            <param name="done">the flag to check if false and set it to true</param>
            <param name="s">The ISubscription to cancel.</param>
        </member>
        <member name="M:Reactor.Core.ExceptionHelper.ThrowOrDrop(System.Exception)">
            <summary>
            Throw if a fatal exception or else drop it.
            </summary>
            <param name="ex">The exception.</param>
        </member>
        <member name="M:Reactor.Core.ExceptionHelper.AddError(System.Exception@,System.Exception)">
            <summary>
            Atomically sets the given Exception on the target or combines the existing
            Exception with the provided through an AggregateException.
            </summary>
            <param name="error">The target field.</param>
            <param name="ex">The new exception to add</param>
            <returns>True if successful, false if the target field already contained the terminated instance.</returns>
        </member>
        <member name="M:Reactor.Core.ExceptionHelper.Terminate(System.Exception@)">
            <summary>
            Atomically swaps in the terminated Exception instance if not already done
            and returns the previous Exception the target field held.
            </summary>
            <param name="error">The target field</param>
            <returns>The previous Exception instance or the terminated instance.</returns>
        </member>
        <member name="M:Reactor.Core.ExceptionHelper.IsTerminated(System.Exception)">
            <summary>
            Returns true if the given exception is the
            terminated instance.
            </summary>
            <param name="e">The exception to check.</param>
            <returns>True if the given exception is the terminated instance.</returns>
        </member>
        <member name="T:Reactor.Core.PublishProcessor`1">
            <summary>
            A processor that dispatches signals to its Subscriber and coordinates
            requests in a lockstep fashion.
            This type of IProcessor mandates the call to OnSubscribe().
            </summary>
            <typeparam name="T">The value type dispatched</typeparam>
        </member>
        <member name="P:Reactor.Core.PublishProcessor`1.HasSubscribers">
            <inheritDoc/>
        </member>
        <member name="P:Reactor.Core.PublishProcessor`1.IsComplete">
            <inheritDoc/>
        </member>
        <member name="P:Reactor.Core.PublishProcessor`1.HasError">
            <inheritDoc/>
        </member>
        <member name="P:Reactor.Core.PublishProcessor`1.Error">
            <inheritDoc/>
        </member>
        <member name="M:Reactor.Core.PublishProcessor`1.#ctor">
            <summary>
            Constructs a PublishProcessor with the default
            prefetch amount of <see cref="P:Reactor.Core.Flux.BufferSize"/>.
            </summary>
        </member>
        <member name="M:Reactor.Core.PublishProcessor`1.#ctor(System.Int32)">
            <summary>
            Constructs a PublishProcessor with the given
            prefetch amount (rounded to the next power-of-two).
            </summary>
            <param name="prefetch">The prefetch amount</param>
        </member>
        <member name="M:Reactor.Core.PublishProcessor`1.Dispose">
            <inheritDoc/>
        </member>
        <member name="M:Reactor.Core.PublishProcessor`1.OnSubscribe(Reactive.Streams.ISubscription)">
            <inheritDoc/>
        </member>
        <member name="M:Reactor.Core.PublishProcessor`1.OnComplete">
            <inheritDoc/>
        </member>
        <member name="M:Reactor.Core.PublishProcessor`1.OnError(System.Exception)">
            <inheritDoc/>
        </member>
        <member name="M:Reactor.Core.PublishProcessor`1.OnNext(`0)">
            <inheritDoc/>
        </member>
        <member name="M:Reactor.Core.PublishProcessor`1.Subscribe(Reactive.Streams.ISubscriber{`0})">
            <inheritDoc/>
        </member>
        <member name="T:Reactor.Core.ITimeSource">
            <summary>
            Interface indicating a Time source that can tell the current time in UTC
            milliseconds
            </summary>
        </member>
        <member name="P:Reactor.Core.ITimeSource.NowUtc">
            <summary>
            The current UTC time.
            </summary>
        </member>
        <member name="T:Reactor.Core.IScheduling">
            <summary>
            Interface to indicate support for non-delayed scheduling of tasks.
            </summary>
        </member>
        <member name="M:Reactor.Core.IScheduling.Schedule(System.Action)">
            <summary>
            Schedules the given task on this scheduler/worker non-delayed execution.
            </summary>
            <param name="task">task the task to execute</param>
            <returns>The Cancellation instance that let's one cancel this particular task.
            If the Scheduler has been shut down, the <see cref="P:Reactor.Core.SchedulerHelper.Rejected"/> instance is returned.</returns>
        </member>
        <member name="T:Reactor.Core.ITimedScheduling">
            <summary>
            Interface to indicate support for delayed and periodic scheduling of tasks.
            </summary>
        </member>
        <member name="M:Reactor.Core.ITimedScheduling.Schedule(System.Action,System.TimeSpan)">
            <summary>
            Schedules the execution of the given task with the given delay amount.
            </summary>
            <param name="task">The task to execute.</param>
            <param name="delay">The delay amount</param>
            <returns>The IDisposable to cancel the task</returns>
        </member>
        <member name="M:Reactor.Core.ITimedScheduling.Schedule(System.Action,System.TimeSpan,System.TimeSpan)">
            <summary>
            Schedules a periodic execution of the given task with the given initial delay and period.
            </summary>
            <param name="task">The tast to execute periodically</param>
            <param name="initialDelay">The initial delay</param>
            <param name="period">The period amount</param>
            <returns>The IDisposable to cancel the periodic task</returns>
        </member>
        <member name="T:Reactor.Core.Scheduler">
            <summary>
            Provides an abstract asychronous boundary to operators.
            </summary>
        </member>
        <member name="M:Reactor.Core.Scheduler.Start">
            <summary>
            Instructs this Scheduler to prepare itself for running tasks
            directly or through its Workers.
            </summary>
        </member>
        <member name="M:Reactor.Core.Scheduler.Shutdown">
            <summary>
            Instructs this Scheduler to release all resources and reject
            any new tasks to be executed.
            </summary>
        </member>
        <member name="M:Reactor.Core.Scheduler.CreateWorker">
            <summary>
            Creates a worker of this Scheduler that executed task in a strict
            FIFO order, guaranteed non-concurrently with each other.
            </summary>
            <returns>The Worker instance.</returns>
        </member>
        <member name="T:Reactor.Core.Worker">
            <summary>
            A worker representing an asynchronous boundary that executes tasks in
            a FIFO order, guaranteed non-concurrently with respect to each other.
            </summary>
        </member>
        <member name="T:Reactor.Core.TimedScheduler">
            <summary>
            Provides an abstract, timed asychronous boundary to operators.
            </summary>
        </member>
        <member name="M:Reactor.Core.TimedScheduler.CreateTimedWorker">
            <summary>
            Creates a timed worker of this Scheduler that executed task in a strict
            FIFO order, guaranteed non-concurrently with each other.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Reactor.Core.TimedWorker">
            <summary>
            A timed worker representing an asynchronous boundary that executes tasks in
            a FIFO order, possibly delayed and guaranteed non-concurrently with respect
            to each other (delayed or non-delayed alike).
            </summary>
        </member>
        <member name="T:Reactor.Core.SchedulerHelper">
            <summary>
            Utility methods to help with schedulers.
            </summary>
        </member>
        <member name="P:Reactor.Core.SchedulerHelper.Rejected">
            <summary>
            The singleton instance of a rejected IDisposable indicator.
            </summary>
        </member>
        <member name="M:Reactor.Core.SchedulerHelper.UtcMillis(System.DateTimeOffset)">
            <summary>
            Converts the DateTimeOffset into total number of milliseconds since the epoch.
            </summary>
            <param name="dt"></param>
            <returns></returns>
        </member>
        <member name="T:Reactor.Core.RejectedDisposable">
            <summary>
            The class representing a rejected task's IDisposable
            </summary>
        </member>
        <member name="T:Reactor.Core.scheduler.DefaultScheduler">
            <summary>
            A scheduler that runs tasks on the task pool.
            </summary>
        </member>
        <member name="P:Reactor.Core.scheduler.DefaultScheduler.Instance">
            <summary>
            Returns the singleton instance of this scheduler
            </summary>
        </member>
        <member name="P:Reactor.Core.scheduler.DefaultScheduler.NowUtc">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.scheduler.DefaultScheduler.CreateTimedWorker">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.scheduler.DefaultScheduler.CreateWorker">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.scheduler.DefaultScheduler.Schedule(System.Action)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.scheduler.DefaultScheduler.Schedule(System.Action,System.TimeSpan)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.scheduler.DefaultScheduler.Schedule(System.Action,System.TimeSpan,System.TimeSpan)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.scheduler.DefaultScheduler.Shutdown">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.scheduler.DefaultScheduler.Start">
            <inheritdoc/>
        </member>
        <member name="P:Reactor.Core.scheduler.DefaultWorker.NowUtc">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.scheduler.DefaultWorker.Schedule(System.Action,System.TimeSpan)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.scheduler.DefaultWorker.Schedule(System.Action,System.TimeSpan,System.TimeSpan)">
            <inheritdoc/>
        </member>
        <member name="T:Reactor.Core.scheduler.DefaultTask">
            <summary>
            The wrapper that has back reference to the worker and captures
            exceptions thrown by the wrapped Action.
            </summary>
        </member>
        <member name="T:Reactor.Core.scheduler.PeriodicTask">
            <summary>
            Wraps an action and manages a fixed-rate periodic execution of it.
            </summary>
        </member>
        <member name="T:Reactor.Core.scheduler.ImmediateScheduler">
            <summary>
            A basic scheduler that executes actions immediately on the caller thread.
            Useful in conjunction with <see cref="M:Reactor.Core.Flux.PublishOn``1(Reactor.Core.IFlux{``0},Reactor.Core.Scheduler,System.Int32,System.Boolean)"/>
            to rebatch downstream requests.
            </summary>
        </member>
        <member name="P:Reactor.Core.scheduler.ImmediateScheduler.Instance">
            <summary>
            Returns the singleton instance of this scheduler.
            </summary>
        </member>
        <member name="M:Reactor.Core.scheduler.ImmediateScheduler.CreateWorker">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.scheduler.ImmediateScheduler.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.scheduler.ImmediateScheduler.Schedule(System.Action)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.scheduler.ImmediateScheduler.Shutdown">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.scheduler.ImmediateScheduler.Start">
            <inheritdoc/>
        </member>
        <member name="T:Reactor.Core.ISignalEmitter`1">
            <summary>
            API for emitting signals based on requests.
            </summary>
            <typeparam name="T">The value type.</typeparam>
        </member>
        <member name="M:Reactor.Core.ISignalEmitter`1.Next(`0)">
            <summary>
            Signal the next value. Should be called at most once per generator invocation.
            </summary>
            <param name="t">The value to signal</param>
        </member>
        <member name="M:Reactor.Core.ISignalEmitter`1.Error(System.Exception)">
            <summary>
            Signal an error. Can be called directly after calling <see cref="M:Reactor.Core.ISignalEmitter`1.Next(`0)"/>.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Reactor.Core.ISignalEmitter`1.Complete">
            <summary>
            Signal a completion. Can be called directly after calling <see cref="M:Reactor.Core.ISignalEmitter`1.Next(`0)"/>.
            </summary>
        </member>
        <member name="T:Reactor.Core.subscriber.BasicConditionalSubscriber`2">
            <summary>
            Base class for conditional subscribers, referencing a downstream
            conditional subscriber and having a done and ISubscription field.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="U"></typeparam>
        </member>
        <member name="F:Reactor.Core.subscriber.BasicConditionalSubscriber`2.actual">
            <summary>
            The actual child ISubscriber.
            </summary>
        </member>
        <member name="M:Reactor.Core.subscriber.BasicConditionalSubscriber`2.BeforeSubscribe">
            <summary>
            Called after a successful OnSubscribe call but
            before the downstream's OnSubscribe is called with this.
            </summary>
        </member>
        <member name="M:Reactor.Core.subscriber.BasicConditionalSubscriber`2.AfterSubscribe">
            <summary>
            Called once the OnSubscribe has been called the first time
            and this has been set on the child ISubscriber.
            </summary>
        </member>
        <member name="M:Reactor.Core.subscriber.BasicConditionalSubscriber`2.Complete">
            <summary>
            Complete the actual ISubscriber if the sequence is not already done.
            </summary>
        </member>
        <member name="M:Reactor.Core.subscriber.BasicConditionalSubscriber`2.Error(System.Exception)">
            <summary>
            Signal an error to the actual ISubscriber if the sequence is not already done.
            </summary>
        </member>
        <member name="M:Reactor.Core.subscriber.BasicConditionalSubscriber`2.Fail(System.Exception)">
            <summary>
            Rethrows a fatal exception, cancels the ISubscription and
            calls <see cref="M:Reactor.Core.subscriber.BasicConditionalSubscriber`2.Error(System.Exception)"/>
            </summary>
            <param name="ex">The exception to rethrow or signal</param>
        </member>
        <member name="F:Reactor.Core.subscriber.BasicFuseableConditionalSubscriber`2.actual">
            <summary>
            The actual child ISubscriber.
            </summary>
        </member>
        <member name="F:Reactor.Core.subscriber.BasicFuseableConditionalSubscriber`2.qs">
            <summary>
            If not null, the upstream is fuseable.
            </summary>
        </member>
        <member name="M:Reactor.Core.subscriber.BasicFuseableConditionalSubscriber`2.BeforeSubscribe">
            <summary>
            Called after a successful OnSubscribe call but
            before the downstream's OnSubscribe is called with this.
            </summary>
            <returns>True if calling the downstream's OnSubscribe can happen.</returns>
        </member>
        <member name="M:Reactor.Core.subscriber.BasicFuseableConditionalSubscriber`2.AfterSubscribe">
            <summary>
            Called once the OnSubscribe has been called the first time
            and this has been set on the child ISubscriber.
            </summary>
        </member>
        <member name="M:Reactor.Core.subscriber.BasicFuseableConditionalSubscriber`2.Complete">
            <summary>
            Complete the actual ISubscriber if the sequence is not already done.
            </summary>
        </member>
        <member name="M:Reactor.Core.subscriber.BasicFuseableConditionalSubscriber`2.Error(System.Exception)">
            <summary>
            Signal an error to the actual ISubscriber if the sequence is not already done.
            </summary>
        </member>
        <member name="M:Reactor.Core.subscriber.BasicFuseableConditionalSubscriber`2.Fail(System.Exception)">
            <summary>
            Rethrows a fatal exception, cancels the ISubscription and
            calls <see cref="M:Reactor.Core.subscriber.BasicFuseableConditionalSubscriber`2.Error(System.Exception)"/>
            </summary>
            <param name="ex">The exception to rethrow or signal</param>
        </member>
        <member name="M:Reactor.Core.subscriber.BasicFuseableConditionalSubscriber`2.IsEmpty">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.subscriber.BasicFuseableConditionalSubscriber`2.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.subscriber.BasicFuseableConditionalSubscriber`2.TransitiveAnyFusion(System.Int32)">
            <summary>
            Forward the mode request to the upstream IQueueSubscription and
            set the mode it returns.
            If the upstream is not an IQueueSubscription, <see cref="F:Reactor.Core.flow.FuseableHelper.NONE"/>
            is returned.
            </summary>
            <param name="mode">The incoming fusion mode.</param>
            <returns>The established fusion mode</returns>
        </member>
        <member name="M:Reactor.Core.subscriber.BasicFuseableConditionalSubscriber`2.TransitiveBoundaryFusion(System.Int32)">
            <summary>
            Unless the mode contains the <see cref="F:Reactor.Core.flow.FuseableHelper.BOUNDARY"/> flag,
            forward the mode request to the upstream IQueueSubscription and
            set the mode it returns.
            If the upstream is not an IQueueSubscription, <see cref="F:Reactor.Core.flow.FuseableHelper.NONE"/>
            is returned.
            </summary>
            <param name="mode">The incoming fusion mode.</param>
            <returns>The established fusion mode</returns>
        </member>
        <member name="T:Reactor.Core.subscriber.BasicFuseableSubscriber`2">
            <summary>
            Abstract base class for ISubscribers that may receive an upstream
            IQueueSubscription and themselves want to offer IQueueSubscription.
            </summary>
            <typeparam name="T">The input value type.</typeparam>
            <typeparam name="U">The output value type.</typeparam>
        </member>
        <member name="F:Reactor.Core.subscriber.BasicFuseableSubscriber`2.actual">
            <summary>
            The actual child ISubscriber.
            </summary>
        </member>
        <member name="F:Reactor.Core.subscriber.BasicFuseableSubscriber`2.qs">
            <summary>
            If not null, the upstream is fuseable.
            </summary>
        </member>
        <member name="F:Reactor.Core.subscriber.BasicFuseableSubscriber`2.fusionMode">
            <summary>
            The established fusion mode. See <see cref="T:Reactor.Core.flow.FuseableHelper"/> constants.
            </summary>
        </member>
        <member name="M:Reactor.Core.subscriber.BasicFuseableSubscriber`2.BeforeSubscribe">
            <summary>
            Called after a successful OnSubscribe call but
            before the downstream's OnSubscribe is called with this.
            </summary>
            <returns>True if calling the downstream's OnSubscribe can happen.</returns>
        </member>
        <member name="M:Reactor.Core.subscriber.BasicFuseableSubscriber`2.AfterSubscribe">
            <summary>
            Called once the OnSubscribe has been called the first time
            and this has been set on the child ISubscriber.
            </summary>
        </member>
        <member name="M:Reactor.Core.subscriber.BasicFuseableSubscriber`2.Complete">
            <summary>
            Complete the actual ISubscriber if the sequence is not already done.
            </summary>
        </member>
        <member name="M:Reactor.Core.subscriber.BasicFuseableSubscriber`2.Error(System.Exception)">
            <summary>
            Signal an error to the actual ISubscriber if the sequence is not already done.
            </summary>
        </member>
        <member name="M:Reactor.Core.subscriber.BasicFuseableSubscriber`2.Fail(System.Exception)">
            <summary>
            Rethrows a fatal exception, cancels the ISubscription and
            calls <see cref="M:Reactor.Core.subscriber.BasicFuseableSubscriber`2.Error(System.Exception)"/>
            </summary>
            <param name="ex">The exception to rethrow or signal</param>
        </member>
        <member name="M:Reactor.Core.subscriber.BasicFuseableSubscriber`2.IsEmpty">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.subscriber.BasicFuseableSubscriber`2.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.subscriber.BasicFuseableSubscriber`2.TransitiveAnyFusion(System.Int32)">
            <summary>
            Forward the mode request to the upstream IQueueSubscription and
            set the mode it returns.
            If the upstream is not an IQueueSubscription, <see cref="F:Reactor.Core.flow.FuseableHelper.NONE"/>
            is returned.
            </summary>
            <param name="mode">The incoming fusion mode.</param>
            <returns>The established fusion mode</returns>
        </member>
        <member name="M:Reactor.Core.subscriber.BasicFuseableSubscriber`2.TransitiveBoundaryFusion(System.Int32)">
            <summary>
            Unless the mode contains the <see cref="F:Reactor.Core.flow.FuseableHelper.BOUNDARY"/> flag,
            forward the mode request to the upstream IQueueSubscription and
            set the mode it returns.
            If the upstream is not an IQueueSubscription, <see cref="F:Reactor.Core.flow.FuseableHelper.NONE"/>
            is returned.
            </summary>
            <param name="mode">The incoming fusion mode.</param>
            <returns>The established fusion mode</returns>
        </member>
        <member name="T:Reactor.Core.subscriber.BasicSinglePostCompleteSubscriber`2">
            <summary>
            Base class for operators that want to signal one extra value after the 
            upstream has completed.
            Call <seealso cref="M:Reactor.Core.subscriber.BasicSinglePostCompleteSubscriber`2.Complete(`1)"/> to signal the post-complete value.
            </summary>
            <typeparam name="T">The input value type.</typeparam>
            <typeparam name="R">The output value type</typeparam>
        </member>
        <member name="F:Reactor.Core.subscriber.BasicSinglePostCompleteSubscriber`2.produced">
            <summary>
            Tracks the amount produced before completion.
            </summary>
        </member>
        <member name="M:Reactor.Core.subscriber.BasicSinglePostCompleteSubscriber`2.Complete(`1)">
            <summary>
            Prepares the value to be the post-complete value.
            </summary>
            <param name="value">The value to signal post-complete.</param>
        </member>
        <member name="M:Reactor.Core.subscriber.BasicSinglePostCompleteSubscriber`2.Produced(System.Int64)">
            <summary>
            Atomically subtract the given amount from the requested amount.
            </summary>
            <param name="n">The value to subtract, positive (not verified)</param>
        </member>
        <member name="T:Reactor.Core.subscriber.TestSubscriber`1">
            <summary>
            An ISubscriber with built-in assertions for testing synchronous
            and asynchronous IFlux and IMono sequences.
            </summary>
            <typeparam name="T">The consumed value type.</typeparam>
        </member>
        <member name="F:Reactor.Core.subscriber.TestSubscriber`1.valueCount">
            <summary>
            Number of items received, use Volatile reads on this.
            </summary>
        </member>
        <member name="F:Reactor.Core.subscriber.TestSubscriber`1.lastTimestamp">
            <summary>
            When the last item was received, UTC milliseconds, use Volatile reads on this.
            </summary>
        </member>
        <member name="P:Reactor.Core.subscriber.TestSubscriber`1.ValueCount">
            <summary>
            The number of received OnNext values.
            </summary>
        </member>
        <member name="P:Reactor.Core.subscriber.TestSubscriber`1.Values">
            <summary>
            The received OnNext values list.
            </summary>
        </member>
        <member name="P:Reactor.Core.subscriber.TestSubscriber`1.Errors">
            <summary>
            The received OnError exception list.
            </summary>
        </member>
        <member name="P:Reactor.Core.subscriber.TestSubscriber`1.Completions">
            <summary>
            The received OnComplete count.
            </summary>
        </member>
        <member name="M:Reactor.Core.subscriber.TestSubscriber`1.#ctor(System.Int64,System.Int32)">
            <summary>
            Constructs a new TestSubscriber instance with an optional
            initial request amount.
            </summary>
            <param name="initialRequest">The initial request amount.</param>
            <param name="fusionMode">The fusion mode to establish.</param>
        </member>
        <member name="M:Reactor.Core.subscriber.TestSubscriber`1.OnSubscribe">
            <summary>
            Subscribe with the Empty Subscription instance.
            </summary>
        </member>
        <member name="M:Reactor.Core.subscriber.TestSubscriber`1.OnSubscribe(Reactive.Streams.ISubscription)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.subscriber.TestSubscriber`1.OnNext(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.subscriber.TestSubscriber`1.OnError(System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.subscriber.TestSubscriber`1.OnComplete">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.subscriber.TestSubscriber`1.Request(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.subscriber.TestSubscriber`1.Cancel">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.subscriber.TestSubscriber`1.AssertFuseable">
            <summary>
            Assert that the upstream called OnSubscribe with an IQueueSubscription instance.
            </summary>
            <returns>This</returns>
        </member>
        <member name="M:Reactor.Core.subscriber.TestSubscriber`1.AssertNoValues">
            <summary>
            Assert that no OnNext has been called.
            </summary>
            <returns>This</returns>
        </member>
        <member name="M:Reactor.Core.subscriber.TestSubscriber`1.AssertValueCount(System.Int32)">
            <summary>
            Assert that OnNext has been called the specified number of times.
            </summary>
            <param name="n">The expected number of times OnNext has been called.</param>
            <returns></returns>
        </member>
        <member name="M:Reactor.Core.subscriber.TestSubscriber`1.AssertValues(`0[])">
            <summary>
            Assert that OnNext has been called with values in the order and in the numbers
            the expected array contains them.
            </summary>
            <param name="expected">The array of expected values</param>
            <returns>This</returns>
        </member>
        <member name="M:Reactor.Core.subscriber.TestSubscriber`1.AssertNoError">
            <summary>
            Assert that OnError has not been called.
            </summary>
            <returns>This</returns>
        </member>
        <member name="M:Reactor.Core.subscriber.TestSubscriber`1.AssertError(System.Exception)">
            <summary>
            Assert that OnError has been called once with the exact Exception instance.
            </summary>
            <param name="ex">The expected exception instance</param>
            <returns>This</returns>
        </member>
        <member name="M:Reactor.Core.subscriber.TestSubscriber`1.AssertError``1">
            <summary>
            Assert that there is exactly one Exception which is a of type E.
            </summary>
            <typeparam name="E">The expected exception type</typeparam>
            <returns>This</returns>
        </member>
        <member name="M:Reactor.Core.subscriber.TestSubscriber`1.AssertError(System.Func{System.Exception,System.Boolean})">
            <summary>
            Assert that there is exactly on Exception and the given predicate returns
            true of it.
            </summary>
            <param name="predicate">The predicate to run.</param>
            <returns>This</returns>
        </member>
        <member name="M:Reactor.Core.subscriber.TestSubscriber`1.AssertErrorMessage(System.String)">
            <summary>
            Assert that there is exactly one Exception which has the specified error message.
            </summary>
            <param name="expectedMessage">The expected error message</param>
            <returns>This</returns>
        </member>
        <member name="M:Reactor.Core.subscriber.TestSubscriber`1.AssertComplete">
            <summary>
            Assert that there has been exactly one completion signal received.
            </summary>
            <returns>This</returns>
        </member>
        <member name="M:Reactor.Core.subscriber.TestSubscriber`1.AssertNotComplete">
            <summary>
            Asser tthat there has been no completion signal received.
            </summary>
            <returns>This</returns>
        </member>
        <member name="M:Reactor.Core.subscriber.TestSubscriber`1.AssertFusionMode(System.Int32)">
            <summary>
            Assert that the given fusion mode has been established.
            </summary>
            <param name="mode">The expected fusion mode, <see cref="T:Reactor.Core.flow.FuseableHelper"/> constants.</param>
            <returns>This</returns>
        </member>
        <member name="M:Reactor.Core.subscriber.TestSubscriber`1.AwaitTerminalEvent">
            <summary>
            Waits for an OnError or OnComplete signal.
            </summary>
            <returns>This</returns>
        </member>
        <member name="M:Reactor.Core.subscriber.TestSubscriber`1.AwaitTerminalEvent(System.TimeSpan)">
            <summary>
            Waits for an OnError or OnComplete signal for the given
            </summary>
            <param name="timeout">The time to wait</param>
            <returns>This</returns>
        </member>
        <member name="M:Reactor.Core.subscriber.TestSubscriber`1.AssertNoEvents">
            <summary>
            Assert that no OnNext, OnError and OnComplete was called.
            </summary>
            <returns>This</returns>
        </member>
        <member name="M:Reactor.Core.subscriber.TestSubscriber`1.AssertResult(`0[])">
            <summary>
            Assert that this TestSubscriber received the given OnNext values
            followed by an OnComplete.
            </summary>
            <param name="expected">The array of expected values</param>
            <returns>This</returns>
        </member>
        <member name="M:Reactor.Core.subscriber.TestSubscriber`1.AssertSubscribed">
            <summary>
            Assert that the upstream has called OnSubscribe with a proper ISubscription.
            </summary>
            <returns>This</returns>
        </member>
        <member name="M:Reactor.Core.subscriber.TestSubscriber`1.AssertNotSubscribed">
            <summary>
            Assert that the upstream has not called OnSubscribe yet.
            </summary>
            <returns>This</returns>
        </member>
        <member name="T:Reactor.Core.subscriber.BasicRejectingSubscription`1">
            <summary>
            A IQueueuSubscription that reject all fusion.
            </summary>
            <typeparam name="T">The output value type</typeparam>
        </member>
        <member name="T:Reactor.Core.subscriber.BasicSubscriber`2">
            <summary>
            Base class for subscribers with an actual ISubscriber, a done flag and
            a sequentially set ISubscription.
            </summary>
            <typeparam name="T">The input value type</typeparam>
            <typeparam name="U">The output value type</typeparam>
        </member>
        <member name="F:Reactor.Core.subscriber.BasicSubscriber`2.actual">
            <summary>
            The actual child ISubscriber.
            </summary>
        </member>
        <member name="M:Reactor.Core.subscriber.BasicSubscriber`2.BeforeSubscribe">
            <summary>
            Called after a successful OnSubscribe call but
            before the downstream's OnSubscribe is called with this.
            </summary>
        </member>
        <member name="M:Reactor.Core.subscriber.BasicSubscriber`2.AfterSubscribe">
            <summary>
            Called once the OnSubscribe has been called the first time
            and this has been set on the child ISubscriber.
            </summary>
        </member>
        <member name="M:Reactor.Core.subscriber.BasicSubscriber`2.Complete">
            <summary>
            Complete the actual ISubscriber if the sequence is not already done.
            </summary>
        </member>
        <member name="M:Reactor.Core.subscriber.BasicSubscriber`2.Error(System.Exception)">
            <summary>
            Signal an error to the actual ISubscriber if the sequence is not already done.
            </summary>
        </member>
        <member name="M:Reactor.Core.subscriber.BasicSubscriber`2.Fail(System.Exception)">
            <summary>
            Rethrows a fatal exception, cancels the ISubscription and
            calls <see cref="M:Reactor.Core.subscriber.BasicSubscriber`2.Error(System.Exception)"/>
            </summary>
            <param name="ex">The exception to rethrow or signal</param>
        </member>
        <member name="T:Reactor.Core.subscriber.BlockingFirstSubscriber`1">
            <summary>
            Blocks until the first value has been emitted or the upstream is empty.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Reactor.Core.subscriber.BlockingLastSubscriber`1">
            <summary>
            Blocks until the last value has been emitted or the upstream is empty.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Reactor.Core.subscriber.DeferredScalarSubscriber`2">
            <summary>
            A subscriber that takes values and produces a single output in a fuseable,
            backpressure aware manner.
            </summary>
            <typeparam name="T">The input value type</typeparam>
            <typeparam name="R">The single output value type</typeparam>
        </member>
        <member name="F:Reactor.Core.subscriber.DeferredScalarSubscriber`2.s">
            <summary>
            The ISubscription to the upstream.
            </summary>
        </member>
        <member name="M:Reactor.Core.subscriber.DeferredScalarSubscriber`2.#ctor(Reactive.Streams.ISubscriber{`1})">
            <summary>
            Constructs an instance with the given actual downstream subscriber.
            </summary>
            <param name="actual">The downstream subscriber</param>
        </member>
        <member name="M:Reactor.Core.subscriber.DeferredScalarSubscriber`2.OnComplete">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.subscriber.DeferredScalarSubscriber`2.OnError(System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.subscriber.DeferredScalarSubscriber`2.OnNext(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.subscriber.DeferredScalarSubscriber`2.OnSubscribe(Reactive.Streams.ISubscription)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.subscriber.DeferredScalarSubscriber`2.OnStart">
            <summary>
            Called after this instance has been sent to downstream via OnSubscribe.
            </summary>
        </member>
        <member name="M:Reactor.Core.subscriber.DeferredScalarSubscriber`2.Cancel">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.subscriber.DeferredScalarSubscriber`2.Error(System.Exception)">
            <summary>
            Set the done flag and signal the exception.
            </summary>
            <param name="ex">The exception to signal</param>
        </member>
        <member name="M:Reactor.Core.subscriber.DeferredScalarSubscriber`2.Fail(System.Exception)">
            <summary>
            Rethrow the exception if fatal, otherwise cancel the subscription
            and signal the exception via <see cref="M:Reactor.Core.subscriber.DeferredScalarSubscriber`2.Error(System.Exception)"/>.
            </summary>
            <param name="ex">The exception to check and signal</param>
        </member>
        <member name="T:Reactor.Core.subscription.DeferredScalarSubscription`1">
            <summary>
            Can hold onto a single value that may appear later
            and emits it on request.
            </summary>
            <typeparam name="T">The value type.</typeparam>
        </member>
        <member name="F:Reactor.Core.subscription.DeferredScalarSubscription`1.actual">
            <summary>
            The actual downstream subscriber.
            </summary>
        </member>
        <member name="F:Reactor.Core.subscription.DeferredScalarSubscription`1.state">
            <summary>
            The current state.
            </summary>
        </member>
        <member name="F:Reactor.Core.subscription.DeferredScalarSubscription`1.CANCELLED">
            <summary>
            Indicates a cancelled state.
            </summary>
        </member>
        <member name="F:Reactor.Core.subscription.DeferredScalarSubscription`1.value">
            <summary>
            The value storage.
            </summary>
        </member>
        <member name="M:Reactor.Core.subscription.DeferredScalarSubscription`1.#ctor(Reactive.Streams.ISubscriber{`0})">
            <summary>
            Constructs a DeferredScalarSubscription with the target ISubscriber.
            </summary>
            <param name="actual">The ISubscriber to send signals to.</param>
        </member>
        <member name="M:Reactor.Core.subscription.DeferredScalarSubscription`1.Error(System.Exception)">
            <summary>
            Signal an exception to the downstream ISubscriber.
            </summary>
            <param name="ex">The exception to signal</param>
        </member>
        <member name="M:Reactor.Core.subscription.DeferredScalarSubscription`1.Complete">
            <summary>
            Signal a valueless completion to the downsream ISubscriber.
            </summary>
        </member>
        <member name="M:Reactor.Core.subscription.DeferredScalarSubscription`1.Complete(`0)">
            <summary>
            Complete with the single value and emit it if
            there is request for it.
            This should be called at most once.
            </summary>
            <param name="v">The value to signal</param>
        </member>
        <member name="M:Reactor.Core.subscription.DeferredScalarSubscription`1.Request(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.subscription.DeferredScalarSubscription`1.RequestFusion(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.subscription.DeferredScalarSubscription`1.Offer(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.subscription.DeferredScalarSubscription`1.Poll(`0@)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.subscription.DeferredScalarSubscription`1.IsEmpty">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.subscription.DeferredScalarSubscription`1.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.subscription.DeferredScalarSubscription`1.Cancel">
            <inheritdoc/>
        </member>
        <member name="T:Reactor.Core.subscription.NeverSubscription`1">
            <summary>
            Represents an empty subscription that ignores requests and cancellation.
            </summary>
            <typeparam name="T">The value type (no value is emitted)</typeparam>
        </member>
        <member name="P:Reactor.Core.subscription.NeverSubscription`1.Instance">
            <summary>
            Returns the singleton instance of the EmptySubscription class.
            </summary>
        </member>
        <member name="M:Reactor.Core.subscription.NeverSubscription`1.Cancel">
            <inheritdoc />
        </member>
        <member name="M:Reactor.Core.subscription.NeverSubscription`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:Reactor.Core.subscription.NeverSubscription`1.IsEmpty">
            <inheritdoc />
        </member>
        <member name="M:Reactor.Core.subscription.NeverSubscription`1.Offer(`0)">
            <inheritdoc />
        </member>
        <member name="M:Reactor.Core.subscription.NeverSubscription`1.Poll(`0@)">
            <inheritdoc />
        </member>
        <member name="M:Reactor.Core.subscription.NeverSubscription`1.Request(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Reactor.Core.subscription.NeverSubscription`1.RequestFusion(System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Reactor.Core.subscription.EmptySubscription`1">
            <summary>
            Represents an empty subscription that ignores requests and cancellation.
            </summary>
            <typeparam name="T">The value type (no value is emitted)</typeparam>
        </member>
        <member name="P:Reactor.Core.subscription.EmptySubscription`1.Instance">
            <summary>
            Returns the singleton instance of the EmptySubscription class.
            </summary>
        </member>
        <member name="M:Reactor.Core.subscription.EmptySubscription`1.Error(Reactive.Streams.ISubscriber{`0},System.Exception)">
            <summary>
            Sets the empty instance on the ISubscriber and calls OnError with the Exception.
            </summary>
            <param name="s">The target ISubscriber</param>
            <param name="ex">The exception to send</param>
        </member>
        <member name="M:Reactor.Core.subscription.EmptySubscription`1.Complete(Reactive.Streams.ISubscriber{`0})">
            <summary>
            Sets the empty instance on the ISubscriber and calls OnComplete.
            </summary>
            <param name="s">The target ISubscriber</param>
        </member>
        <member name="M:Reactor.Core.subscription.EmptySubscription`1.Cancel">
            <inheritdoc />
        </member>
        <member name="M:Reactor.Core.subscription.EmptySubscription`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:Reactor.Core.subscription.EmptySubscription`1.IsEmpty">
            <inheritdoc />
        </member>
        <member name="M:Reactor.Core.subscription.EmptySubscription`1.Offer(`0)">
            <inheritdoc />
        </member>
        <member name="M:Reactor.Core.subscription.EmptySubscription`1.Poll(`0@)">
            <inheritdoc />
        </member>
        <member name="M:Reactor.Core.subscription.EmptySubscription`1.Request(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Reactor.Core.subscription.EmptySubscription`1.RequestFusion(System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Reactor.Core.subscription.ScalarSubscription`1">
            <summary>
            A fuseable subscription that emits a single value on request or poll.
            </summary>
            <typeparam name="T">The value type</typeparam>
        </member>
        <member name="M:Reactor.Core.subscription.ScalarSubscription`1.#ctor(Reactive.Streams.ISubscriber{`0},`0)">
            <summary>
            Constructs a ScalarSubscription with the target ISubscriber and value to
            emit on request.
            </summary>
            <param name="actual">The target ISubscriber</param>
            <param name="value">The value to emit</param>
        </member>
        <member name="M:Reactor.Core.subscription.ScalarSubscription`1.RequestFusion(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.subscription.ScalarSubscription`1.Offer(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.subscription.ScalarSubscription`1.Poll(`0@)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.subscription.ScalarSubscription`1.IsEmpty">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.subscription.ScalarSubscription`1.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.subscription.ScalarSubscription`1.Request(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.subscription.ScalarSubscription`1.Cancel">
            <inheritdoc/>
        </member>
        <member name="T:Reactor.Core.subscription.SubscriptionArbiterStruct">
            <summary>
            Arbitrates the requests between subsequent ISubscriptions.
            </summary>
        </member>
        <member name="M:Reactor.Core.subscription.SubscriptionArbiterStruct.Clear">
            <summary>
            Clears the current ISubscription with plain access.
            Use this to prevent cancelling a contained ISubscription that has terminated.
            </summary>
        </member>
        <member name="M:Reactor.Core.subscription.SubscriptionArbiterStruct.Set(Reactive.Streams.ISubscription)">
            <summary>
            Atomically set the next ISubscription on this arbiter.
            </summary>
            <param name="s">The new ISubscription instance.</param>
        </member>
        <member name="M:Reactor.Core.subscription.SubscriptionArbiterStruct.ValidateAndRequest(System.Int64)">
            <summary>
            Request the specified amount (validated) from the current ISubscription if present
            or accumulate it until an ISubscription is set.
            </summary>
            <param name="n">The request amount, positive (validated)</param>
        </member>
        <member name="M:Reactor.Core.subscription.SubscriptionArbiterStruct.Request(System.Int64)">
            <summary>
            Request the specified amount (not validated) from the current ISubscription if present
            or accumulate it until an ISubscription is set.
            </summary>
            <param name="n">The request amount, positive (not validated)</param>
        </member>
        <member name="M:Reactor.Core.subscription.SubscriptionArbiterStruct.Produced(System.Int64)">
            <summary>
            Indicate the number of items produced and subtract it from
            the current requested amount (if not unbounded).
            </summary>
            <param name="n">The produced amount, positive (not verified).</param>
        </member>
        <member name="M:Reactor.Core.subscription.SubscriptionArbiterStruct.Cancel">
            <summary>
            Cancel the current any subsequent ISubscription.
            </summary>
        </member>
        <member name="T:Reactor.Core.subscription.SubscriptionHelper">
            <summary>
            Utility methods for working with Subscriptions.
            </summary>
        </member>
        <member name="M:Reactor.Core.subscription.SubscriptionHelper.Validate(System.Int64)">
            <summary>
            Verify that the request amount is positive, signal an ArgumentOutOfRangeException
            to ReactorCorePlugins.
            </summary>
            <param name="n">The request amount.</param>
            <returns>True if the amount is valid, false otherwise</returns>
        </member>
        <member name="M:Reactor.Core.subscription.SubscriptionHelper.Validate(Reactive.Streams.ISubscription@,Reactive.Streams.ISubscription)">
            <summary>
            Verifies that the target field is null and sets it to the non-null ISubscription provided
            or signal an InvalidOperationException if the target field is not null and not the Cancelled
            instance. In these cases, the new ISubscription is cancelled.
            </summary>
            <param name="current">The target field</param>
            <param name="s">The new ISubscription instance to set</param>
            <returns>True if successful, false if the target field is not empty</returns>
        </member>
        <member name="M:Reactor.Core.subscription.SubscriptionHelper.Validate``1(Reactor.Core.flow.IQueueSubscription{``0}@,Reactor.Core.flow.IQueueSubscription{``0})">
            <summary>
            Verifies that the target field is null and sets it to the non-null ISubscription provided
            or signal an InvalidOperationException if the target field is not null and not the Cancelled
            instance. In these cases, the new ISubscription is cancelled.
            </summary>
            <param name="current">The target field</param>
            <param name="s">The new ISubscription instance to set</param>
            <returns>True if successful, false if the target field is not empty</returns>
        </member>
        <member name="M:Reactor.Core.subscription.SubscriptionHelper.IsCancelled(Reactive.Streams.ISubscription@)">
            <summary>
            Check if the given reference contains the Cancelled instance.
            </summary>
            <param name="s">The source field</param>
            <returns>True if it contains the Cancelled instance.</returns>
        </member>
        <member name="M:Reactor.Core.subscription.SubscriptionHelper.IsCancelled(Reactive.Streams.ISubscription)">
            <summary>
            Check if the given value is the Cancelled instance.
            </summary>
            <param name="s">The source field</param>
            <returns>True if it is the Cancelled instance.</returns>
        </member>
        <member name="M:Reactor.Core.subscription.SubscriptionHelper.SetOnce(Reactive.Streams.ISubscription@,Reactive.Streams.ISubscription)">
            <summary>
            Atomically set the given ISubscription on a null target or cancel it if the
            target is not empty or contains the Cancelled instance.
            </summary>
            <param name="current">The target field</param>
            <param name="s">The new value</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:Reactor.Core.subscription.SubscriptionHelper.Replace(Reactive.Streams.ISubscription@,Reactive.Streams.ISubscription)">
            <summary>
            Atomically replace the ISubscription in the target field or cancel
            the new ISubscription if the target contains the Cancelled instance.
            </summary>
            <param name="current">The target field</param>
            <param name="s">The new ISubscription instance</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:Reactor.Core.subscription.SubscriptionHelper.Set(Reactive.Streams.ISubscription@,Reactive.Streams.ISubscription)">
            <summary>
            Atomically set the ISubscription in the target field, cancelling
            the previous value or cancel the new ISubscription if the target 
            contains the Cancelled instance.
            </summary>
            <param name="current">The target field</param>
            <param name="s">The new ISubscription instance</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:Reactor.Core.subscription.SubscriptionHelper.Cancel(Reactive.Streams.ISubscription@)">
            <summary>
            Atomically cancel the target field of ISubscription.
            </summary>
            <param name="current">The target field</param>
            <returns>True if the caller thread was the one successfully cancelling the content of the field</returns>
        </member>
        <member name="F:Reactor.Core.subscription.SubscriptionHelper.Cancelled">
            <summary>
            The singleton instance of a ISubscription denoting a cancelled state.
            </summary>
        </member>
        <member name="T:Reactor.Core.subscription.SubscriptionHelper.CancelledSubscription">
            <summary>
            Class representing a no-op cancelled ISubscription.
            </summary>
        </member>
        <member name="T:Reactor.Core.subscription.SubscriptionHelper.CancelledQueueSubscription`1">
            <summary>
            Class representing a no-op cancelled ISubscription.
            </summary>
        </member>
        <member name="T:Reactor.Core.Timed`1">
            <summary>
            Structure holding a value and an Utc timestamp or time interval.
            </summary>
            <typeparam name="T">The value type</typeparam>
        </member>
        <member name="P:Reactor.Core.Timed`1.Value">
            <summary>
            The held value.
            </summary>
        </member>
        <member name="P:Reactor.Core.Timed`1.TimeMillis">
            <summary>
            The held timestamp
            </summary>
        </member>
        <member name="M:Reactor.Core.Timed`1.#ctor(`0,System.Int64)">
            <summary>
            Initializes the Timed instance.
            </summary>
            <param name="value">The value</param>
            <param name="timeMillis">The time in milliseconds</param>
        </member>
        <member name="T:Reactor.Core.UnicastProcessor`1">
            <summary>
            An IFluxProcessor (IProcessor) that allows a single ISubscriber at most, buffers
            incoming values in an unbounded manner and replays it to the single subscriber.
            </summary>
            <remarks>
            The class publicly implements IQueueSubscription for performance reasons
            but one should not call its methods.
            </remarks>
            <typeparam name="T">The input and output type.</typeparam>
        </member>
        <member name="P:Reactor.Core.UnicastProcessor`1.HasSubscribers">
            <inheritDoc/>
        </member>
        <member name="P:Reactor.Core.UnicastProcessor`1.IsComplete">
            <inheritDoc/>
        </member>
        <member name="P:Reactor.Core.UnicastProcessor`1.HasError">
            <inheritDoc/>
        </member>
        <member name="P:Reactor.Core.UnicastProcessor`1.Error">
            <inheritDoc/>
        </member>
        <member name="M:Reactor.Core.UnicastProcessor`1.#ctor(System.Action)">
            <summary>
            Construct a default UnicastProcessor with an optional termination action
            and the default Flux.BufferSize queue.
            </summary>
            <param name="onTerminated">The optional termination action.</param>
        </member>
        <member name="M:Reactor.Core.UnicastProcessor`1.#ctor(System.Int32,System.Action)">
            <summary>
            Construct a default UnicastProcessor with an optional termination action
            and the given capacity-hinted queue.
            </summary>
            <param name="capacityHint">The expected number of items getting buffered</param>
            <param name="onTerminated">The optional termination action.</param>
        </member>
        <member name="M:Reactor.Core.UnicastProcessor`1.OnSubscribe(Reactive.Streams.ISubscription)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.UnicastProcessor`1.OnNext(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.UnicastProcessor`1.OnError(System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.UnicastProcessor`1.OnComplete">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.UnicastProcessor`1.Subscribe(Reactive.Streams.ISubscriber{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.UnicastProcessor`1.Request(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.UnicastProcessor`1.Cancel">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.UnicastProcessor`1.RequestFusion(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.UnicastProcessor`1.Offer(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.UnicastProcessor`1.Poll(`0@)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.UnicastProcessor`1.IsEmpty">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.UnicastProcessor`1.Clear">
            <inheritdoc/>
        </member>
        <member name="T:Reactor.Core.util.BackpressureHelper">
            <summary>
            Helper methods for working with backpressure request amounts.
            </summary>
        </member>
        <member name="M:Reactor.Core.util.BackpressureHelper.AddCap(System.Int64,System.Int64)">
            <summary>
            Add two positive integers and cap the sum at long.MaxValue.
            </summary>
            <param name="a">The first value, non-negative (not verified)</param>
            <param name="b">The second value, non-negative (not verified)</param>
            <returns></returns>
        </member>
        <member name="M:Reactor.Core.util.BackpressureHelper.MultiplyCap(System.Int64,System.Int64)">
            <summary>
            Multiplies two long values and caps the result at long.MaxValue.
            </summary>
            <param name="a">The first value, non-negative (not verified).</param>
            <param name="b">The second value, non-negative (not verified).</param>
            <returns>The product of <paramref name="a"/> and <paramref name="b"/> capped at <see cref="F:System.Int64.MaxValue"/></returns>
        </member>
        <member name="M:Reactor.Core.util.BackpressureHelper.GetAndAddCap(System.Int64@,System.Int64)">
            <summary>
            Atomically add the given number to the requested field and
            cap the sum at long.MaxValue.
            </summary>
            <param name="requested">The target requested field</param>
            <param name="n">The request amount. Not validated</param>
            <returns>The previous value of the requested field</returns>
        </member>
        <member name="M:Reactor.Core.util.BackpressureHelper.Produced(System.Int64@,System.Int64)">
            <summary>
            Atomically decrement the target requested field by the given positive number
            and return the new value.
            </summary>
            <param name="requested">The target field</param>
            <param name="n">The value to subtract, positive (not verified)</param>
            <returns>The new field value after the subtraction.</returns>
        </member>
        <member name="M:Reactor.Core.util.BackpressureHelper.DeferredSetOnce(Reactive.Streams.ISubscription@,System.Int64@,Reactive.Streams.ISubscription)">
            <summary>
            Atomically set the new ISubscription once on the current field and request
            any accumulated value.
            </summary>
            <param name="current">The current ISubscription field</param>
            <param name="requested">The requested amount field</param>
            <param name="s">The new ISubscription to set once</param>
        </member>
        <member name="M:Reactor.Core.util.BackpressureHelper.DeferredRequest(Reactive.Streams.ISubscription@,System.Int64@,System.Int64)">
            <summary>
            Accumulate the request amounts (validated) until the current field is null or
            request directly from the ISubscription.
            </summary>
            <param name="current">The current ISubscription field</param>
            <param name="requested">The requested amount field</param>
            <param name="n">The requested amount to request directly or accumulate until the current field is not null. Validated</param>
        </member>
        <member name="M:Reactor.Core.util.BackpressureHelper.MissingBackpressureException(System.String)">
            <summary>
            Returns an exception instance indicating the lack of requests.
            </summary>
            <param name="message">The optional message</param>
            <returns>The Exception instance.</returns>
        </member>
        <member name="M:Reactor.Core.util.BackpressureHelper.ValidateAndAddCap(System.Int64@,System.Int64)">
            <summary>
            Validates and atomically adds the amount to the requested field.
            </summary>
            <param name="requested">The target requested field.</param>
            <param name="n">The amount to add, positive (validated).</param>
            <returns>The amount of the requested field before the addition.</returns>
        </member>
        <member name="M:Reactor.Core.util.BackpressureHelper.PostCompleteRequest``1(System.Int64@,System.Int64,Reactive.Streams.ISubscriber{``0},Reactor.Core.flow.IQueue{``0},System.Boolean@)">
            <summary>
            Atomically add to the requested amount and drain the queue
            if in post-complete state.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="requested">The requested field.</param>
            <param name="n">The request amount, positive (not validated).</param>
            <param name="s">The target ISubscriber</param>
            <param name="queue">The queue to drain.</param>
            <param name="cancelled">The cancelled field</param>
            <returns>True if in post-complete mode.</returns>
        </member>
        <member name="M:Reactor.Core.util.BackpressureHelper.PostComplete``1(System.Int64@,Reactive.Streams.ISubscriber{``0},Reactor.Core.flow.IQueue{``0},System.Boolean@)">
            <summary>
            Atomically switches to post-complete mode and drains the queue.
            </summary>
            <typeparam name="T">The value type</typeparam>
            <param name="requested">The requested field.</param>
            <param name="s">The ISubscriber</param>
            <param name="queue">The queue</param>
            <param name="cancelled">The cancelled field.</param>
        </member>
        <member name="T:Reactor.Core.util.DisposableHelper">
            <summary>
            Utility methods to work with IDisposable fields.
            </summary>
        </member>
        <member name="P:Reactor.Core.util.DisposableHelper.Disposed">
            <summary>
            The Disposed instance.
            </summary>
        </member>
        <member name="M:Reactor.Core.util.DisposableHelper.IsDisposed(System.IDisposable)">
            <summary>
            Check if the given IDisposable is the disposed instance.
            </summary>
            <param name="d">The IDisposable to check.</param>
            <returns>True if the <paramref name="d"/> is the disposed instance</returns>
        </member>
        <member name="M:Reactor.Core.util.DisposableHelper.IsDisposed(System.IDisposable@)">
            <summary>
            Check if the given field contains the disposed instance.
            </summary>
            <param name="d">The IDisposable field to check.</param>
            <returns>True if the <paramref name="d"/> contains the disposed instance</returns>
        </member>
        <member name="M:Reactor.Core.util.DisposableHelper.Dispose(System.IDisposable@)">
            <summary>
            Atomically dispose the contents of the field if not already disposed.
            </summary>
            <param name="d">The target field to dispose</param>
            <returns>True if the current thread successfully disposed the contents</returns>
        </member>
        <member name="M:Reactor.Core.util.DisposableHelper.Replace(System.IDisposable@,System.IDisposable)">
            <summary>
            Atomically replaces the contents of the target field or disposes the
            new IDisposable if the field contains the disposed instance.
            </summary>
            <param name="d">The target field.</param>
            <param name="a">The new IDisposable instance</param>
            <returns>True if successful, false if the target contains the disposed instance</returns>
        </member>
        <member name="M:Reactor.Core.util.DisposableHelper.Set(System.IDisposable@,System.IDisposable)">
            <summary>
            Atomically sets the contents of the target field, disposing the old
            valuue or disposes thenew IDisposable if the field contains the 
            disposed instance.
            </summary>
            <param name="d">The target field.</param>
            <param name="a">The new IDisposable instance</param>
            <returns>True if successful, false if the target contains the disposed instance</returns>
        </member>
        <member name="T:Reactor.Core.util.Disposed">
            <summary>
            The class representing a disposed IDisposable
            </summary>
        </member>
        <member name="T:Reactor.Core.util.Pad56">
            <summary>
            A pad of 56 bytes, useful in combination with a 8 byte data field.
            </summary>
        </member>
        <member name="T:Reactor.Core.util.Pad64">
            <summary>
            A pad of 64 bytes.
            </summary>
        </member>
        <member name="T:Reactor.Core.util.Pad120">
            <summary>
            A pad of 120 bytes, useful in combination with a 8 byte data field.
            </summary>
        </member>
        <member name="T:Reactor.Core.util.Pad112">
            <summary>
            A pad of 112 bytes, useful in combination with a 16 byte data field.
            </summary>
        </member>
        <member name="T:Reactor.Core.util.Pad104">
            <summary>
            A pad of 14 bytes, useful in combination with a 24 byte data field.
            </summary>
        </member>
        <member name="T:Reactor.Core.util.Pad128">
            <summary>
            A pad of 128 bytes.
            </summary>
        </member>
        <member name="T:Reactor.Core.util.HalfSerializerStruct">
            <summary>
            Performs half-serialization of events, that is, only one
            source calls OnNext but any other source may call OnError and
            OnComplete concurrently.
            </summary>
        </member>
        <member name="F:Reactor.Core.util.HalfSerializerStruct.wip">
            <summary>
            The work-in-progress counter.
            </summary>
        </member>
        <member name="F:Reactor.Core.util.HalfSerializerStruct.error">
            <summary>
            The exception to terminate with or null
            </summary>
        </member>
        <member name="M:Reactor.Core.util.HalfSerializerStruct.OnNext``1(Reactive.Streams.ISubscriber{``0},``0)">
            <summary>
            Signal an OnNext value and terminate if there was a concurrent OnError
            or OnComplete call. Should be called from one thread at a time.
            </summary>
            <typeparam name="T">The value type</typeparam>
            <param name="actual">The target ISubscriber</param>
            <param name="value">The value to signal</param>
        </member>
        <member name="M:Reactor.Core.util.HalfSerializerStruct.TryOnNext``1(Reactor.Core.flow.IConditionalSubscriber{``0},``0)">
            <summary>
            Signal an OnNext value conditionally and terminate if 
            there was a concurrent OnError or OnComplete call.
            Should be called from one thread at a time.
            </summary>
            <typeparam name="T">The value type</typeparam>
            <param name="actual">The target ISubscriber</param>
            <param name="value">The value to signal</param>
            <returns>What the TryOnNext returns or false if terminated</returns>
        </member>
        <member name="T:Reactor.Core.util.IndexedMultipeDisposableStruct">
            <summary>
            Tracks IDisposables with an associated index and replaces them
            only if an incoming index is bigger than the hosted index.
            </summary>
        </member>
        <member name="T:Reactor.Core.util.IndexedMultipleDisposable">
            <summary>
            Tracks IDisposables with an associated index and replaces them
            only if an incoming index is bigger than the hosted index.
            </summary>
        </member>
        <member name="T:Reactor.Core.util.MultipleDisposable">
            <summary>
            An IDisposable holding onto another IDisposable and allows
            replacing it atomically, optionally disposing the previous one.
            </summary>
        </member>
        <member name="T:Reactor.Core.util.MultiSourceHelper">
            <summary>
            Utility methods for dealing with values in an array or IEnumerable and
            converting them into an array.
            </summary>
        </member>
        <member name="T:Reactor.Core.util.ObjectHelper">
            <summary>
            Object-helper methods.
            </summary>
        </member>
        <member name="M:Reactor.Core.util.ObjectHelper.RequireNonNull``1(``0,System.String)">
            <summary>
            Throws an Exception if the value is null, returns it otherwise.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="value">The value.</param>
            <param name="errorMessage">The error message.</param>
            <returns>The value.</returns>
        </member>
        <member name="T:Reactor.Core.util.OrderedItem`1">
            <summary>
            Basic implementation of IOrderedItem.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Reactor.Core.util.OrderedItem`1.Index">
            <inheritdoc/>
        </member>
        <member name="P:Reactor.Core.util.OrderedItem`1.Value">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.util.OrderedItem`1.#ctor(System.Int64,`0)">
            <summary>
            Constructs an ordered item with the given index and value.
            </summary>
            <param name="index">The index.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:Reactor.Core.util.OrderedItem`1.CompareTo(Reactor.Core.IOrderedItem{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.util.OrderedItem`1.Replace``1(``0)">
            <inheritdoc/>
        </member>
        <member name="T:Reactor.Core.util.QueueDrainHelper">
            <summary>
            Helper methods to work with the regular queue-drain serialization approach
            </summary>
        </member>
        <member name="M:Reactor.Core.util.QueueDrainHelper.Enter(System.Int32@)">
            <summary>
            Atomically increment the work-in-progress counter and return true if
            it transitioned from 0 to 1.
            </summary>
            <param name="wip">The work-in-progress field</param>
            <returns>True if the counter transitioned from 0 to 1</returns>
        </member>
        <member name="M:Reactor.Core.util.QueueDrainHelper.Leave(System.Int32@,System.Int32)">
            <summary>
            Atomically try to decrement the work-in-progress counter and return
            its new value.
            </summary>
            <param name="wip">The target work-in-progress counter field</param>
            <param name="missed">The number to decrement the counter, positive (not verified)</param>
            <returns>The new work-in-progress value</returns>
        </member>
        <member name="M:Reactor.Core.util.QueueDrainHelper.CreateQueue``1(System.Int32)">
            <summary>
            Constructs a queue based on the prefetch value.
            </summary>
            <typeparam name="T">The queue element type</typeparam>
            <param name="capacityHint">If negative, an SpscLinkedArrayQueue is created with
            capacity hint as the absolute of capacityHint,
            if one, an SpscOneQueue is created. Otherwise, an SpscArrayQueue is created with
            the capacityHint.</param>
            <returns></returns>
        </member>
        <member name="M:Reactor.Core.util.QueueDrainHelper.TryEnter(System.Int32@)">
            <summary>
            Tries to enter the drain mode via a fast-path method.
            </summary>
            <param name="wip">The work-in-progress field to change</param>
            <returns>True if successful</returns>
        </member>
        <member name="T:Reactor.Core.util.QueueHelper">
            <summary>
            Utility methods to work with IQueues.
            </summary>
        </member>
        <member name="M:Reactor.Core.util.QueueHelper.Round(System.Int32)">
            <summary>
            Rounds the value to a power-of-2 if not already power of 2
            </summary>
            <param name="v">The value to round</param>
            <returns>The rounded value.</returns>
        </member>
        <member name="M:Reactor.Core.util.QueueHelper.Clear``1(Reactor.Core.flow.IQueue{``0})">
            <summary>
            Clear the queue by polling until no more items left.
            </summary>
            <typeparam name="T">The value type.</typeparam>
            <param name="q">The source queue.</param>
        </member>
        <member name="T:Reactor.Core.util.SpscArrayQueue`1">
            <summary>
            A single-producer, single-consumer, bounded capacity concurrent queue.
            </summary>
            <typeparam name="T">The stored value type</typeparam>
        </member>
        <member name="M:Reactor.Core.util.SpscArrayQueue`1.#ctor(System.Int32)">
            <summary>
            Constructs an instance with the given capacity rounded up to
            the next power-of-2 value.
            </summary>
            <param name="capacity">The target capacity.</param>
        </member>
        <member name="M:Reactor.Core.util.SpscArrayQueue`1.Offer(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.util.SpscArrayQueue`1.Poll(`0@)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.util.SpscArrayQueue`1.IsEmpty">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.util.SpscArrayQueue`1.Clear">
            <inheritdoc/>
        </member>
        <member name="F:Reactor.Core.util.SpscArrayQueue`1.Entry.flag">
            <summary>
            Indicates the occupancy of the entry.
            </summary>
        </member>
        <member name="F:Reactor.Core.util.SpscArrayQueue`1.Entry.value">
            <summary>
            The entry value.
            </summary>
        </member>
        <member name="P:Reactor.Core.util.SpscArrayQueue`1.Entry.Flag">
            <summary>
            Accesses the flag field with Volatile.
            </summary>
        </member>
        <member name="F:Reactor.Core.util.SpscArrayQueue`1.EntryPadded.flag">
            <summary>
            Indicates the occupancy of the entry.
            </summary>
        </member>
        <member name="F:Reactor.Core.util.SpscArrayQueue`1.EntryPadded.value">
            <summary>
            The entry value.
            </summary>
        </member>
        <member name="P:Reactor.Core.util.SpscArrayQueue`1.EntryPadded.Flag">
            <summary>
            Accesses the flag field with Volatile.
            </summary>
        </member>
        <member name="T:Reactor.Core.util.SpscFreelistTracker`1">
            <summary>
            A single-adder, single-remover tracker of values plus
            a separate free-slot queue.
            </summary>
            <typeparam name="T">The value type tracked.</typeparam>
        </member>
        <member name="T:Reactor.Core.util.SpscLinkedArrayQueue`1">
            <summary>
            A single-producer, single-consumer, unbounded concurrent queue
            with an island size to avoid frequent reallocation.
            </summary>
            <typeparam name="T">The stored value type</typeparam>
        </member>
        <member name="M:Reactor.Core.util.SpscLinkedArrayQueue`1.#ctor(System.Int32)">
            <summary>
            Constructs an instance with the given capacity rounded up to
            the next power-of-2 value.
            </summary>
            <param name="capacity">The target capacity.</param>
        </member>
        <member name="M:Reactor.Core.util.SpscLinkedArrayQueue`1.Offer(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.util.SpscLinkedArrayQueue`1.Poll(`0@)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.util.SpscLinkedArrayQueue`1.IsEmpty">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.util.SpscLinkedArrayQueue`1.Clear">
            <inheritdoc/>
        </member>
        <member name="F:Reactor.Core.util.SpscLinkedArrayQueue`1.Entry.flag">
            <summary>
            Indicates the occupancy of the entry.
            </summary>
        </member>
        <member name="F:Reactor.Core.util.SpscLinkedArrayQueue`1.Entry.value">
            <summary>
            The entry value.
            </summary>
        </member>
        <member name="F:Reactor.Core.util.SpscLinkedArrayQueue`1.Entry.next">
            <summary>
            Pointer to the next array.
            </summary>
        </member>
        <member name="F:Reactor.Core.util.SpscLinkedArrayQueue`1.Entry.pad">
            <summary>
            Pad out to 32 bytes.
            </summary>
        </member>
        <member name="P:Reactor.Core.util.SpscLinkedArrayQueue`1.Entry.Flag">
            <summary>
            Accesses the flag field with Volatile.
            </summary>
        </member>
        <member name="P:Reactor.Core.util.SpscLinkedArrayQueue`1.Entry.FlagPlain">
            <summary>
            Write into the flag with plain access mode.
            </summary>
        </member>
        <member name="T:Reactor.Core.util.SpscOneQueue`1">
            <summary>
            A queue with capacity of one.
            </summary>
            <typeparam name="T">The value type.</typeparam>
        </member>
        <member name="M:Reactor.Core.util.SpscOneQueue`1.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.util.SpscOneQueue`1.IsEmpty">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.util.SpscOneQueue`1.Offer(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Reactor.Core.util.SpscOneQueue`1.Poll(`0@)">
            <inheritdoc/>
        </member>
        <member name="T:Reactor.Core.util.TrackingArray`1">
            <summary>
            A copy-on-write array container with a terminal state.
            Call Init() to setup the initial array to be empty.
            </summary>
            <typeparam name="T">The tracked value type.</typeparam>
        </member>
        <member name="M:Reactor.Core.util.TrackingArray`1.Array">
            <summary>
            Atomically reads the current array of items.
            </summary>
            <returns>The current array of items</returns>
        </member>
        <member name="M:Reactor.Core.util.TrackingArray`1.Add(`0)">
            <summary>
            Atomically adds the item to this container or returns
            false if the container has been terminated.
            </summary>
            <param name="item">The item to add</param>
            <returns>True if successful, false if the container has been termianted.</returns>
        </member>
        <member name="M:Reactor.Core.util.TrackingArray`1.Remove(`0)">
            <summary>
            Removes an item from this container.
            </summary>
            <param name="item">The item to remove</param>
        </member>
        <member name="M:Reactor.Core.util.TrackingArray`1.Terminate">
            <summary>
            Atomically terminates this container and returns the last
            array of items.
            </summary>
            <returns>The last array of items</returns>
        </member>
        <member name="M:Reactor.Core.util.TrackingArray`1.IsTerminated">
            <summary>
            Checks if this container has been terminated.
            </summary>
            <returns>True if this container has been terminated.</returns>
        </member>
        <member name="T:Reactor.Core.Void">
            <summary>
            A type that can't have instances.
            </summary>
        </member>
        <member name="T:Reactive.Streams.IProcessor`1">
            <summary>
            A Processor represents a processing stagewhich is both a <see cref="T:Reactive.Streams.ISubscriber`1"/>
            and a <see cref="T:Reactive.Streams.IPublisher`1"/> and obeys the contracts of both.
            </summary>
            <typeparam name="T">The type of element signaled to the <see cref="T:Reactive.Streams.ISubscriber`1"/> and to the <see cref="T:Reactive.Streams.IPublisher`1"/> side</typeparam>
        </member>
    </members>
</doc>
